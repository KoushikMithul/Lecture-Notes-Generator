{
  "video_name": "TBT_6b_2020-09-25 11-29-19_TBTCode 00_00_04-00_35_19~8",
  "video_path": "data/raw/videos/TBT_6b_2020-09-25 11-29-19_TBTCode 00_00_04-00_35_19~8.mkv",
  "duration_seconds": 2109.626,
  "transcript": [
    {
      "text": " Let me include the files.",
      "start_time": 0.0,
      "end_time": 7.0
    },
    {
      "text": " So, first and foremost for a threaded binary tree, the node structure that I would like",
      "start_time": 7.0,
      "end_time": 21.88
    },
    {
      "text": "",
      "start_time": 21.88,
      "end_time": 0.0
    },
    {
      "text": " to have is like that of a binary surgery node structure.",
      "start_time": 8.12,
      "end_time": null
    },
    {
      "text": " with information field, then I have a pointer to the left and a pointer to the right child.",
      "start_time": 30.0,
      "end_time": 41.08
    },
    {
      "text": " In addition, I am going to use a field called as R thread.",
      "start_time": 41.08,
      "end_time": 48.28
    },
    {
      "text": " The reason behind this is something like this.",
      "start_time": 48.28,
      "end_time": 54.92
    },
    {
      "text": "",
      "start_time": 54.92,
      "end_time": 30.0
    },
    {
      "text": " See what happens.",
      "start_time": 35.0,
      "end_time": null
    },
    {
      "text": " is when you have a node, let us say this is 2 and this is 4 and this is 3, the address",
      "start_time": 60.0,
      "end_time": 78.28
    },
    {
      "text": " of this node is 100. So, its left pointer is 100, its right side pointer is 9. Now,",
      "start_time": 78.28,
      "end_time": 85.8
    },
    {
      "text": "",
      "start_time": 85.8,
      "end_time": 60.0
    },
    {
      "text": " In this case the left pointer is null and right side pointer is null.",
      "start_time": 64.2,
      "end_time": null
    },
    {
      "text": " is pointing to let us say 200, this is 200 and in this case the right side pointer is",
      "start_time": 90.0,
      "end_time": 99.96000000000001
    },
    {
      "text": " pointing to 400 which is a thread path. Now if when you inspect the right side pointer",
      "start_time": 99.96000000000001,
      "end_time": 108.36
    },
    {
      "text": " in this case and in this case you observe that the right side pointer has 200 is just",
      "start_time": 108.36,
      "end_time": 116.56
    },
    {
      "text": "",
      "start_time": 116.56,
      "end_time": 90.0
    },
    {
      "text": " number and this right side pointer is 400 which is an",
      "start_time": 93.4,
      "end_time": null
    },
    {
      "text": " address, 200 is an address, 400 is also an address.",
      "start_time": 120.0,
      "end_time": 124.32
    },
    {
      "text": " So, by inspecting you would not know whether it is actually pointing to a child or it is",
      "start_time": 124.32,
      "end_time": 129.32
    },
    {
      "text": " pointing to a thread back thread here.",
      "start_time": 129.32,
      "end_time": 132.16
    },
    {
      "text": " So, we should have a separate field indicating whether the right side pointer which contains",
      "start_time": 132.16,
      "end_time": 138.32
    },
    {
      "text": " an address, is it pointing to a child in which case it is not a thread, I will use a field.",
      "start_time": 138.32,
      "end_time": 145.12
    },
    {
      "text": "",
      "start_time": 145.12,
      "end_time": 120.0
    },
    {
      "text": " In this case 400 is a thread field and therefore, my thread field is a thread field.",
      "start_time": 127.0,
      "end_time": null
    },
    {
      "text": " thread flag is going to contain one. That is why I said a node structure will have four",
      "start_time": 150.0,
      "end_time": 157.08
    },
    {
      "text": " fields in it. One is the information field, one is the left pointer, the other one is",
      "start_time": 157.08,
      "end_time": 164.24
    },
    {
      "text": " the right side pointer. Then you have also the R thread field indicating 0 or 1. 0 indicates",
      "start_time": 164.24,
      "end_time": 171.8
    },
    {
      "text": " right side pointer pointing to a child, 1 here indicates that it is pointing to a thread.",
      "start_time": 171.8,
      "end_time": 177.28
    },
    {
      "text": "",
      "start_time": 177.28,
      "end_time": 150.0
    },
    {
      "text": " So that way a node in this case will have 4.",
      "start_time": 152.76,
      "end_time": null
    },
    {
      "text": " 4 feet. Then I am going to create a tree structure, tree data structure which consists of my root",
      "start_time": 180.0,
      "end_time": 197.96
    },
    {
      "text": "",
      "start_time": 197.96,
      "end_time": 180.0
    },
    {
      "text": " point up. This is my tree.",
      "start_time": 190.24,
      "end_time": null
    },
    {
      "text": " So, now I will have to initialize the root to null.",
      "start_time": 210.0,
      "end_time": 213.72
    },
    {
      "text": " So, I am going to call the init function and make the root null.",
      "start_time": 213.72,
      "end_time": 232.02
    },
    {
      "text": "",
      "start_time": 232.02,
      "end_time": 210.0
    },
    {
      "text": " Then I am going to call the create function.",
      "start_time": 213.52,
      "end_time": null
    },
    {
      "text": " call the create function. Now, in the create function, let me use a temporary pointer and",
      "start_time": 240.0,
      "end_time": 258.76
    },
    {
      "text": " also use some more pointers to traverse and I will also use a variable integer wish.",
      "start_time": 258.76,
      "end_time": 267.52
    },
    {
      "text": "",
      "start_time": 267.52,
      "end_time": 240.0
    },
    {
      "text": " So first and foremost in the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the",
      "start_time": 240.0,
      "end_time": null
    },
    {
      "text": " of a binary search tree which is a threaded tree, I need to create the root node. So, for that",
      "start_time": 270.0,
      "end_time": 276.56
    },
    {
      "text": " I am going to call the make node function. The job of the make node function is to create one node",
      "start_time": 277.28,
      "end_time": 286.32
    },
    {
      "text": " for us and then return the address. So, I will go ahead and start creating the make node function.",
      "start_time": 287.44,
      "end_time": 295.04
    },
    {
      "text": "",
      "start_time": 295.76,
      "end_time": 270.0
    },
    {
      "text": " So make node, fill.",
      "start_time": 277.0,
      "end_time": null
    },
    {
      "text": " create a node. So, I use a temp pointer here as well temp is equal to I will first and",
      "start_time": 300.0,
      "end_time": 307.28
    },
    {
      "text": " foremost of the responsibility of the make node function is to allocate node 1 node",
      "start_time": 307.28,
      "end_time": 315.38
    },
    {
      "text": " memory, allocate memory for 1 node and then temps left temps I am going to accept the",
      "start_time": 315.38,
      "end_time": 327.2
    },
    {
      "text": "",
      "start_time": 327.2,
      "end_time": 300.0
    },
    {
      "text": " information in it.",
      "start_time": 300.84,
      "end_time": null
    },
    {
      "text": " information in it, I read it into the allocated dynamically allocated node and then I am going",
      "start_time": 330.0,
      "end_time": 344.4
    },
    {
      "text": " to set see this is a new node that is getting created.",
      "start_time": 344.4,
      "end_time": 347.68
    },
    {
      "text": " I will set the left pointer to 9, right pointer I will adjust suitably after deciding where",
      "start_time": 347.68,
      "end_time": 353.68
    },
    {
      "text": " that will go in.",
      "start_time": 353.68,
      "end_time": 354.68
    },
    {
      "text": "",
      "start_time": 354.68,
      "end_time": 330.0
    },
    {
      "text": " So, right now I will initially when I create the node I am setting it to null and see",
      "start_time": 335.3,
      "end_time": null
    },
    {
      "text": " Since this new node is going to have a write thread because newly getting created.",
      "start_time": 360.0,
      "end_time": 365.96
    },
    {
      "text": " So write thread will be set at a pointer later once I know where it has to be created I will",
      "start_time": 365.96,
      "end_time": 372.32
    },
    {
      "text": " set it to 1.",
      "start_time": 372.32,
      "end_time": 374.24
    },
    {
      "text": " So return 10 because this node which I created has to be returned back to the caller.",
      "start_time": 374.24,
      "end_time": 382.64
    },
    {
      "text": " So I am returning.",
      "start_time": 382.64,
      "end_time": 383.64
    },
    {
      "text": " Since I am returning the nodes address here which is present in 10 I am going to write",
      "start_time": 383.64,
      "end_time": 389.96
    },
    {
      "text": "",
      "start_time": 389.96,
      "end_time": 360.0
    },
    {
      "text": " Thank you.",
      "start_time": 361.0,
      "end_time": null
    },
    {
      "text": " this as node star. So, this is going to return a pointer to the node, this is my make node",
      "start_time": 390.0,
      "end_time": 396.4
    },
    {
      "text": " function. So, when I call the make node function, you know one root node is created, one node",
      "start_time": 396.4,
      "end_time": 401.52
    },
    {
      "text": " is created and its address is being made to be I mean the address of that such a node",
      "start_time": 401.52,
      "end_time": 407.6
    },
    {
      "text": " is now present in the root because this is the first node that I am creating. So, once",
      "start_time": 407.6,
      "end_time": 412.28
    },
    {
      "text": " the root node is created, then I am going to run in iteration to create other nodes.",
      "start_time": 412.28,
      "end_time": 418.64
    },
    {
      "text": "",
      "start_time": 418.64,
      "end_time": 390.0
    },
    {
      "text": " So, to create other.",
      "start_time": 391.34,
      "end_time": null
    },
    {
      "text": " node I am going to call the make node again, one more node I call and then this address",
      "start_time": 420.0,
      "end_time": 426.84
    },
    {
      "text": " now temporarily have put it in temp.",
      "start_time": 426.84,
      "end_time": 429.8
    },
    {
      "text": " Now I need to make sure that this temp is attached to my existing threaded binary tree",
      "start_time": 429.8,
      "end_time": 434.92
    },
    {
      "text": " and for this I need to traverse in my tree.",
      "start_time": 434.92,
      "end_time": 437.88
    },
    {
      "text": " So what I am going to do is for the traversal I will use two pointers Q and P, P will move",
      "start_time": 437.88,
      "end_time": 444.64
    },
    {
      "text": " forward and Q will traverse behind.",
      "start_time": 444.64,
      "end_time": 449.92
    },
    {
      "text": "",
      "start_time": 449.92,
      "end_time": 420.0
    },
    {
      "text": " Thank you.",
      "start_time": 421.0,
      "end_time": null
    },
    {
      "text": " P is said to the root and then while P is not equal to null, P is not equal to null.",
      "start_time": 450.0,
      "end_time": 464.12
    },
    {
      "text": " As long as P is pointing to nodes, it indicates that we have still not hit a position where",
      "start_time": 464.12,
      "end_time": 470.36
    },
    {
      "text": " we can insert the new node.",
      "start_time": 470.36,
      "end_time": 472.24
    },
    {
      "text": " So we keep moving forward.",
      "start_time": 472.24,
      "end_time": 474.64
    },
    {
      "text": "",
      "start_time": 474.64,
      "end_time": 450.0
    },
    {
      "text": " So Q will come and occupy the place of P and then P has to move forward.",
      "start_time": 455.36,
      "end_time": null
    },
    {
      "text": " either to the left or right that is based on the Thames information. If M info is less",
      "start_time": 480.0,
      "end_time": 489.52
    },
    {
      "text": " than P info, P info then we know that P has to move to the left side, P has to move to",
      "start_time": 489.52,
      "end_time": 500.8
    },
    {
      "text": " the left side. Yes, in this case it is not just P moving to the right side, you have",
      "start_time": 500.8,
      "end_time": 506.28
    },
    {
      "text": "",
      "start_time": 506.28,
      "end_time": 480.0
    },
    {
      "text": " to see you cannot simply move if it is a thread.",
      "start_time": 483.72,
      "end_time": null
    },
    {
      "text": " you cannot move back right. If it is only a child, actual child then you have to traverse,",
      "start_time": 510.0,
      "end_time": 515.12
    },
    {
      "text": " otherwise you cannot move. For example, in this example, so let us say, see in this example,",
      "start_time": 515.12,
      "end_time": 534.32
    },
    {
      "text": "",
      "start_time": 534.32,
      "end_time": 510.0
    },
    {
      "text": " Suppose I want to 38 is 0.",
      "start_time": 517.0,
      "end_time": null
    },
    {
      "text": " present, I want to add let us say 40, if I want to add 40, so your P is here, Q is here,",
      "start_time": 540.0,
      "end_time": 550.16
    },
    {
      "text": " okay.",
      "start_time": 550.16,
      "end_time": 551.16
    },
    {
      "text": " Now 40 is then Q will come to the place of P, it should be now traverse P, it is not",
      "start_time": 551.16,
      "end_time": 557.66
    },
    {
      "text": " about traversing P back because we have already finished traversal.",
      "start_time": 557.66,
      "end_time": 561.08
    },
    {
      "text": " So P is already having a thread now, so we cannot traverse, we have to stop the traversal",
      "start_time": 561.08,
      "end_time": 566.68
    },
    {
      "text": "",
      "start_time": 566.68,
      "end_time": 540.0
    },
    {
      "text": " If P is having a thread, it is time for us to actually attack.",
      "start_time": 543.32,
      "end_time": null
    },
    {
      "text": " it here. Suppose if this was not the case, we had like this, let us say, we had like",
      "start_time": 570.0,
      "end_time": 580.56
    },
    {
      "text": " this already there is a path like this. Now, let us say here, this is already there, I",
      "start_time": 580.56,
      "end_time": 587.84
    },
    {
      "text": " want to now attach 42, let us say, I want to attach 42, this is a temp. So, how do we",
      "start_time": 587.84,
      "end_time": 594.04
    },
    {
      "text": "",
      "start_time": 594.04,
      "end_time": 570.0
    },
    {
      "text": " start here. So, initially, Q is equal to Q is equal to Q is equal to Q is equal to Q",
      "start_time": 587.44,
      "end_time": null
    },
    {
      "text": " is null and p is here. So, 42 is less than 56. So, q will come to the place of this and",
      "start_time": 600.0,
      "end_time": 606.88
    },
    {
      "text": " p will go forward. p is still not a right thread, is it not? That means you have not",
      "start_time": 606.88,
      "end_time": 613.04
    },
    {
      "text": " finished the traversal. So, we are yet to complete the traversal. We have not still",
      "start_time": 613.04,
      "end_time": 619.28
    },
    {
      "text": " found a place for 42. So, 42 is greater than 38. So, q will come to the place of p, q will",
      "start_time": 619.28,
      "end_time": 627.44
    },
    {
      "text": "",
      "start_time": 627.44,
      "end_time": 600.0
    },
    {
      "text": " come to the place of B and B will go.",
      "start_time": 602.56,
      "end_time": null
    },
    {
      "text": " forward now because P will move forward now, please note because it is a child because",
      "start_time": 630.0,
      "end_time": 636.22
    },
    {
      "text": " this P is not a right thread now and 42 is greater than 38, P will move forward.",
      "start_time": 636.22,
      "end_time": 642.44
    },
    {
      "text": " So when P will move forward to the right side, it will move forward to the right side if",
      "start_time": 642.44,
      "end_time": 647.36
    },
    {
      "text": " currently P is not a right thread and 42 is greater than 38, P will move forward.",
      "start_time": 647.36,
      "end_time": 653.32
    },
    {
      "text": " So now Q and P are here.",
      "start_time": 653.32,
      "end_time": 657.32
    },
    {
      "text": "",
      "start_time": 657.32,
      "end_time": 630.0
    },
    {
      "text": " Now again, so in this case, we have a problem with the",
      "start_time": 637.0,
      "end_time": null
    },
    {
      "text": " is 42 is greater than, P is still not null, so I am still not completing, I have still",
      "start_time": 660.0,
      "end_time": 666.88
    },
    {
      "text": " not completed the traversal. So, Q will come to the place of P, but 42 is greater than",
      "start_time": 666.88,
      "end_time": 673.4
    },
    {
      "text": " 40, but does it mean that we have to move P? No, because P is having a right thread",
      "start_time": 673.4,
      "end_time": 679.08
    },
    {
      "text": " now, you cannot move. So, when P is a right thread, you cannot blindly move P to the right",
      "start_time": 679.08,
      "end_time": 683.44
    },
    {
      "text": " side, although 42 is greater than 40. So, if P is a right thread, we have to stop, we",
      "start_time": 683.44,
      "end_time": 688.32
    },
    {
      "text": "",
      "start_time": 688.32,
      "end_time": 660.0
    },
    {
      "text": " know that we have already hit a...",
      "start_time": 661.68,
      "end_time": null
    },
    {
      "text": " place where 42 has to be attached. So, if P is a right thread then we stop the traversal",
      "start_time": 690.0,
      "end_time": 695.32
    },
    {
      "text": " and make sure that whatever 40 was pointing now this will be made to point to and then",
      "start_time": 695.32,
      "end_time": 701.28
    },
    {
      "text": " this P right side will be now pointing to this so that this chain is broken, its R",
      "start_time": 701.28,
      "end_time": 706.44
    },
    {
      "text": " thread will be made as false and this R thread is true that is how the right side is going",
      "start_time": 706.44,
      "end_time": 711.44
    },
    {
      "text": " to be attached. So, this is how the threaded binary tree is going to be created. This is",
      "start_time": 711.44,
      "end_time": 716.6
    },
    {
      "text": "",
      "start_time": 716.6,
      "end_time": 690.0
    },
    {
      "text": " clear if you want to attach something to the right side, what you are going to do is,",
      "start_time": 697.0,
      "end_time": null
    },
    {
      "text": " whatever this was pointing now with this will start pointing as a thread, this will be made",
      "start_time": 720.0,
      "end_time": 724.68
    },
    {
      "text": " as a right actual right child. Therefore, the r thread of this will be set to 0 and",
      "start_time": 724.68,
      "end_time": 730.62
    },
    {
      "text": " r thread of this will be set to 1. This is how I am going to set a new node to the right",
      "start_time": 730.62,
      "end_time": 735.88
    },
    {
      "text": " side. So, let us continue.",
      "start_time": 735.88,
      "end_time": 739.16
    },
    {
      "text": " So, what I am going to do is if temp info in this case you can note while p not null",
      "start_time": 739.16,
      "end_time": 748.28
    },
    {
      "text": "",
      "start_time": 748.28,
      "end_time": 720.0
    },
    {
      "text": " q equal to b if temp in for e.",
      "start_time": 721.76,
      "end_time": null
    },
    {
      "text": " is less than P in 4, P will move to the left side.",
      "start_time": 750.0,
      "end_time": 752.96
    },
    {
      "text": " Else, you can't simply move P now to the right side.",
      "start_time": 752.96,
      "end_time": 757.76
    },
    {
      "text": " We have to check if P has a thread path.",
      "start_time": 757.76,
      "end_time": 762.44
    },
    {
      "text": " If the thread path is true, if P has a thread path, then I am going to just break from it",
      "start_time": 762.44,
      "end_time": 770.68
    },
    {
      "text": " because then also I stop the traversal.",
      "start_time": 770.68,
      "end_time": 773.36
    },
    {
      "text": " So one other condition for which I stop the traversal is P has become null.",
      "start_time": 773.36,
      "end_time": 777.44
    },
    {
      "text": "",
      "start_time": 777.44,
      "end_time": 750.0
    },
    {
      "text": " Otherwise I will stop the traversal.",
      "start_time": 752.32,
      "end_time": null
    },
    {
      "text": " for the case of, for the case of P being right-thread. If it is not a right-thread, then I have to",
      "start_time": 780.0,
      "end_time": 790.96
    },
    {
      "text": " simply move P to the right side because I have to continue with my traversal. So, now when you come",
      "start_time": 790.96,
      "end_time": 796.4
    },
    {
      "text": " out of the y loop, you know that P would have become null, if P has become null, then you know",
      "start_time": 796.4,
      "end_time": 803.84
    },
    {
      "text": "",
      "start_time": 803.84,
      "end_time": 780.0
    },
    {
      "text": " that for sure you have to set this new node to the left side of Q.",
      "start_time": 786.0,
      "end_time": null
    },
    {
      "text": " you have to set it to the left side of Q because you would have said something to the, P would",
      "start_time": 810.0,
      "end_time": 817.92
    },
    {
      "text": " have become null and you have to set it to the left side of the Q, Q would have come",
      "start_time": 817.92,
      "end_time": 824.92
    },
    {
      "text": " to the previous.",
      "start_time": 824.92,
      "end_time": 825.92
    },
    {
      "text": " Yes, it is understood that you are breaking from the while loop because of the thread",
      "start_time": 825.92,
      "end_time": 830.92
    },
    {
      "text": " path, if P is still not null then P is having a right thread because of the thread path you",
      "start_time": 830.92,
      "end_time": 836.0
    },
    {
      "text": " are coming out as while loop.",
      "start_time": 836.0,
      "end_time": 838.2
    },
    {
      "text": "",
      "start_time": 838.2,
      "end_time": 810.0
    },
    {
      "text": " So what I am going to do is I am going to write a text, I am going to write a text,",
      "start_time": 817.0,
      "end_time": null
    },
    {
      "text": " to setRyche to the right side of p in this case, the new node temp that is what I am",
      "start_time": 840.0,
      "end_time": 848.64
    },
    {
      "text": " going to do. So, after I am done with one node creation and insertion into the threaded",
      "start_time": 848.64,
      "end_time": 855.12
    },
    {
      "text": " binary tree, I am going to again ask do you want to add another one or zero to be answering",
      "start_time": 855.12,
      "end_time": 866.88
    },
    {
      "text": "",
      "start_time": 866.88,
      "end_time": 840.0
    },
    {
      "text": " the query then I will accept it in.",
      "start_time": 843.08,
      "end_time": null
    },
    {
      "text": " So, I can write this as wish and then I continue.",
      "start_time": 870.0,
      "end_time": 877.0
    },
    {
      "text": " So as long as there is wish to create node nodes.",
      "start_time": 877.0,
      "end_time": 883.4
    },
    {
      "text": " So here I need to write now set left and set right functions.",
      "start_time": 883.4,
      "end_time": 887.2
    },
    {
      "text": "",
      "start_time": 887.2,
      "end_time": 870.0
    },
    {
      "text": " So let us write that point set left, set left node star p comma node star p.",
      "start_time": 882.2,
      "end_time": null
    },
    {
      "text": " So, what this function does is to set any, I receive two nodes addresses and my job is",
      "start_time": 900.0,
      "end_time": 908.32
    },
    {
      "text": " to set p to the left of p provided p itself is not null.",
      "start_time": 908.32,
      "end_time": 912.56
    },
    {
      "text": " So, I am going to check if p is equal to null, I cannot set it, if p itself is null, how",
      "start_time": 912.56,
      "end_time": 920.36
    },
    {
      "text": " can I set something to the left of p and if p left is already occupied by somebody then",
      "start_time": 920.36,
      "end_time": 926.76
    },
    {
      "text": "",
      "start_time": 926.76,
      "end_time": 900.0
    },
    {
      "text": " also I am not good to set not equal to 9.",
      "start_time": 903.24,
      "end_time": null
    },
    {
      "text": " then I cannot set, I will just return. These are some exceptions that I am taking care.",
      "start_time": 930.0,
      "end_time": 936.0
    },
    {
      "text": " Otherwise I can set to the left of P this T, since I am setting it to the left of P,",
      "start_time": 936.0,
      "end_time": 942.56
    },
    {
      "text": " so you please note that T's right side, T's right side will be the P itself, this is a",
      "start_time": 942.56,
      "end_time": 948.76
    },
    {
      "text": " third part that I am creating and also I am making sure now that the T's right thread",
      "start_time": 948.76,
      "end_time": 955.96
    },
    {
      "text": "",
      "start_time": 955.96,
      "end_time": 930.0
    },
    {
      "text": " is already set to 1 from the initialization itself. So, you need to",
      "start_time": 933.92,
      "end_time": null
    },
    {
      "text": " take care of setting t right to p which is the in order successor. So, p is the in order",
      "start_time": 960.0,
      "end_time": 971.88
    },
    {
      "text": " successor for t when you are setting it to f, you can see that. So, that is how the thread",
      "start_time": 971.88,
      "end_time": 983.92
    },
    {
      "text": "",
      "start_time": 983.92,
      "end_time": 960.0
    },
    {
      "text": " is created. So, we can see that here. So, when you",
      "start_time": 966.16,
      "end_time": null
    },
    {
      "text": " whenever I create a new node 56, if I set something to the left side of a node 12, this",
      "start_time": 990.0,
      "end_time": 998.96
    },
    {
      "text": " is P, this is D. So, you can see that in order successor for 12 is 56. So, T's right side",
      "start_time": 998.96,
      "end_time": 1006.0
    },
    {
      "text": " will point to P through the thread path. So, this thread will be set to 1 anyway that is",
      "start_time": 1006.0,
      "end_time": 1011.56
    },
    {
      "text": " done in the make node itself. So, that change P's left is T, T's right side is P, this",
      "start_time": 1011.56,
      "end_time": 1017.76
    },
    {
      "text": "",
      "start_time": 1017.76,
      "end_time": 990.0
    },
    {
      "text": " is how we are going to set.",
      "start_time": 991.2,
      "end_time": null
    },
    {
      "text": " So, that is what is going to be done.",
      "start_time": 1020.0,
      "end_time": 1025.12
    },
    {
      "text": " So, now we will see the function for set write.",
      "start_time": 1025.12,
      "end_time": 1030.12
    },
    {
      "text": " In the set write function also I am going to accept two pointers, one to which the node",
      "start_time": 1030.12,
      "end_time": 1040.84
    },
    {
      "text": " has to be connected, other one is the new node.",
      "start_time": 1040.84,
      "end_time": 1045.4
    },
    {
      "text": "",
      "start_time": 1045.4,
      "end_time": 1020.0
    },
    {
      "text": " also I will check if p itself is 9.",
      "start_time": 1024.56,
      "end_time": null
    },
    {
      "text": " cannot connect it, so I will just return. Now in this case p is right side is not null,",
      "start_time": 1050.0,
      "end_time": 1055.88
    },
    {
      "text": " please note that. Therefore, we have to check if p is right thread, if p is not a right",
      "start_time": 1055.88,
      "end_time": 1065.52
    },
    {
      "text": " thread, because only if it is a thread I can connect to the right side. If p is not a right",
      "start_time": 1065.52,
      "end_time": 1072.56
    },
    {
      "text": "",
      "start_time": 1072.56,
      "end_time": 1050.0
    },
    {
      "text": " right, right, right, right, right, right, right, right, right, right, right, right, right,",
      "start_time": 1057.0,
      "end_time": null
    },
    {
      "text": " So, if it is already having a child path then I have to just return ok.",
      "start_time": 1080.0,
      "end_time": 1087.44
    },
    {
      "text": " Only if it is a thread then I have to start connecting.",
      "start_time": 1087.44,
      "end_time": 1090.48
    },
    {
      "text": " So, whatever piece right side was pointing to now it should be pointed by the piece right",
      "start_time": 1090.48,
      "end_time": 1100.6
    },
    {
      "text": " side ok.",
      "start_time": 1100.6,
      "end_time": 1104.12
    },
    {
      "text": "",
      "start_time": 1104.12,
      "end_time": 1080.0
    },
    {
      "text": " p right now should be safely modified to point to this D which is the child.",
      "start_time": 1085.76,
      "end_time": null
    },
    {
      "text": " And T now since P right is now pointing to actual child, P's right thread should be",
      "start_time": 1110.0,
      "end_time": 1118.76
    },
    {
      "text": " said to 0, it is no more a thread. T's right thread is anyway positive, so that is fine.",
      "start_time": 1118.76,
      "end_time": 1125.44
    },
    {
      "text": " So, let us see through a diagram that why this is going to be that way. So, now you can see,",
      "start_time": 1125.44,
      "end_time": 1132.88
    },
    {
      "text": "",
      "start_time": 1132.88,
      "end_time": 1110.0
    },
    {
      "text": " t, I am going to attach 18 here, this is your t and this is your p.",
      "start_time": 1116.48,
      "end_time": null
    },
    {
      "text": " I am setting something to the right side of P, P and T. So, what I am going to do is whatever",
      "start_time": 1140.0,
      "end_time": 1146.82
    },
    {
      "text": " P right side was pointing to the thread, now that has to be captured in T. So, T's right",
      "start_time": 1146.82,
      "end_time": 1154.14
    },
    {
      "text": " side should be capturing whatever P's right was pointing to. So, that way this will now",
      "start_time": 1154.14,
      "end_time": 1158.74
    },
    {
      "text": " start pointing to this fellow. Now, this has to be broken. So, P's right side should be",
      "start_time": 1158.74,
      "end_time": 1163.78
    },
    {
      "text": " T, P's right side and this thread is no more true. So, we have to set it to 0 that is what",
      "start_time": 1163.78,
      "end_time": 1169.34
    },
    {
      "text": "",
      "start_time": 1169.34,
      "end_time": 1140.0
    },
    {
      "text": " any troubles.",
      "start_time": 1140.72,
      "end_time": null
    },
    {
      "text": " So, that is what has been done.",
      "start_time": 1170.0,
      "end_time": 1171.44
    },
    {
      "text": " So, here t right is equal to p right and p right is t.",
      "start_time": 1171.44,
      "end_time": 1176.56
    },
    {
      "text": " So, that has been done, t right is equal to p right, p right is t, p r third is 0.",
      "start_time": 1176.56,
      "end_time": 1182.32
    },
    {
      "text": " So, this is the set right function.",
      "start_time": 1182.32,
      "end_time": 1185.24
    },
    {
      "text": " Now, we will look at the traversal.",
      "start_time": 1185.24,
      "end_time": 1189.8
    },
    {
      "text": " The main goal for our moving in for a threaded binary tree was to avoid the usage of the",
      "start_time": 1189.8,
      "end_time": 1195.8
    },
    {
      "text": "",
      "start_time": 1195.8,
      "end_time": 1170.0
    },
    {
      "text": " explicit stack and let us see how that can be done now.",
      "start_time": 1174.08,
      "end_time": null
    },
    {
      "text": " the iterative traversal. So, what I am going to do is here is to create again two temporary",
      "start_time": 1200.0,
      "end_time": 1207.76
    },
    {
      "text": " pointers to traverse through the tree. So, I am going to set P to the root of the tree",
      "start_time": 1207.76,
      "end_time": 1214.84
    },
    {
      "text": " because we have to start the traversal from the root. So, now I am going to keep traversing",
      "start_time": 1214.84,
      "end_time": 1220.8
    },
    {
      "text": " as long as I have nodes to be printed. Initially Q is set to null, initially Q is set to null",
      "start_time": 1220.8,
      "end_time": 1227.52
    },
    {
      "text": "",
      "start_time": 1227.52,
      "end_time": 1200.0
    },
    {
      "text": " and you know that this is in order traversal.",
      "start_time": 1202.4,
      "end_time": null
    },
    {
      "text": " And because of which the sequences you have to traverse the left side tree first, then",
      "start_time": 1230.0,
      "end_time": 1238.24
    },
    {
      "text": " visit the root and then traverse the right side.",
      "start_time": 1238.24,
      "end_time": 1241.04
    },
    {
      "text": " So while P not equal to null, P not equal to null, keep traversing Q and P, Q will come",
      "start_time": 1241.04,
      "end_time": 1251.44
    },
    {
      "text": " to the place of P and P will traverse to the left.",
      "start_time": 1251.44,
      "end_time": 1254.6
    },
    {
      "text": "",
      "start_time": 1254.6,
      "end_time": 1230.0
    },
    {
      "text": " So, this will make sure that P is gone out of the scope and Q would be",
      "start_time": 1235.52,
      "end_time": null
    },
    {
      "text": " be at the place where we have to print. So, I will show that. So, in the threaded binary",
      "start_time": 1260.0,
      "end_time": 1270.16
    },
    {
      "text": " tree here, we will take the example of a threaded binary tree. I will pick up this 65, 62, 78",
      "start_time": 1270.16,
      "end_time": 1289.68
    },
    {
      "text": "",
      "start_time": 1289.68,
      "end_time": 1260.0
    },
    {
      "text": " then",
      "start_time": 1262.0,
      "end_time": null
    },
    {
      "text": " we have 56 and then 63, then this is 58. So, and this is pointing to this thread and this",
      "start_time": 1290.0,
      "end_time": 1302.2
    },
    {
      "text": " is pointing to thread. So, now in this case the way I am going to do is I will start the",
      "start_time": 1302.2,
      "end_time": 1308.12
    },
    {
      "text": " traversal P is here Q is initially null. So, while P not null I have to keep traversing",
      "start_time": 1308.12,
      "end_time": 1316.24
    },
    {
      "text": "",
      "start_time": 1316.24,
      "end_time": 1290.0
    },
    {
      "text": " to the left side. So, what happens is q will come here.",
      "start_time": 1297.0,
      "end_time": null
    },
    {
      "text": " P will go here, then P is not null. So, Q will come here, P will go here, P is not null, Q will",
      "start_time": 1320.0,
      "end_time": 1327.2
    },
    {
      "text": " come here and P has gone out of scope. So, when P becomes null, you know that you have traversed",
      "start_time": 1327.2,
      "end_time": 1334.8
    },
    {
      "text": " down the left side, so that is what has happened. So, you have completely come down to the left.",
      "start_time": 1334.8,
      "end_time": 1341.52
    },
    {
      "text": " So, the since P has become null, there is nothing to the left side. So, it indicates that it is",
      "start_time": 1341.52,
      "end_time": 1346.88
    },
    {
      "text": "",
      "start_time": 1346.88,
      "end_time": 1320.0
    },
    {
      "text": " time for us to print the information of Q provided.",
      "start_time": 1323.12,
      "end_time": null
    },
    {
      "text": " added q is not null. So, if q is not null not equal to null, I will print q's information",
      "start_time": 1350.0,
      "end_time": 1360.34
    },
    {
      "text": " after printing see left visit the root and then go to the right this is a in order after",
      "start_time": 1360.34,
      "end_time": 1365.92
    },
    {
      "text": " printing the root this node now we have to traverse to the right side of the tree. So,",
      "start_time": 1365.92,
      "end_time": 1371.92
    },
    {
      "text": " I will set p to the right side of q. So, p will be set to the right side of q this is",
      "start_time": 1371.92,
      "end_time": 1377.92
    },
    {
      "text": "",
      "start_time": 1377.92,
      "end_time": 1350.0
    },
    {
      "text": " So, what I am going to do now ok.",
      "start_time": 1352.0,
      "end_time": null
    },
    {
      "text": " So, that part of the code let us see. So, if q is not equal to 9, then I am going to",
      "start_time": 1380.0,
      "end_time": 1392.4
    },
    {
      "text": " set print, print the node because it is time for me to print the q's information",
      "start_time": 1393.36,
      "end_time": 1402.88
    },
    {
      "text": "",
      "start_time": 1404.8,
      "end_time": 1380.0
    },
    {
      "text": " ok and then I am going to make the p point to the right.",
      "start_time": 1387.12,
      "end_time": null
    },
    {
      "text": " side of Q. So, P might be pointing to a new tree, P might be pointing to a thread. So,",
      "start_time": 1410.0,
      "end_time": 1416.08
    },
    {
      "text": " we have to find out in this case ok. So, that is what has happened. So, in the example that",
      "start_time": 1416.08,
      "end_time": 1422.72
    },
    {
      "text": " I have picked up, the example that I have picked up, P is pointing to a new tree altogether.",
      "start_time": 1422.72,
      "end_time": 1429.44
    },
    {
      "text": " See, we might have also taken a node here right, this is let us say 57. So, this is",
      "start_time": 1429.44,
      "end_time": 1437.68
    },
    {
      "text": "",
      "start_time": 1437.68,
      "end_time": 1410.0
    },
    {
      "text": " a sub tree now, this is a sub tree.",
      "start_time": 1412.32,
      "end_time": null
    },
    {
      "text": " we have to now finish this part before we move back to the above one.",
      "start_time": 1440.0,
      "end_time": 1444.64
    },
    {
      "text": " So in this case P has been said to the right side, but this is not a thread path.",
      "start_time": 1444.64,
      "end_time": 1449.88
    },
    {
      "text": " It is not choose right side if you look at, it is a child path, it is not a thread path",
      "start_time": 1449.88,
      "end_time": 1455.48
    },
    {
      "text": " because of which it is a new traversing that we have to make up.",
      "start_time": 1455.48,
      "end_time": 1459.32
    },
    {
      "text": " So what happens is it keeps traversing and we print 57 and all that.",
      "start_time": 1459.32,
      "end_time": 1464.76
    },
    {
      "text": "",
      "start_time": 1464.76,
      "end_time": 1440.0
    },
    {
      "text": " Suppose if this were not to be this way, let us say.",
      "start_time": 1447.0,
      "end_time": null
    },
    {
      "text": " If the connection was like this, after completing Q, P will go to the right side of Q. So, P",
      "start_time": 1470.0,
      "end_time": 1480.0
    },
    {
      "text": " will be here. In this case Q has a thread path. If it is going back then it is not about",
      "start_time": 1480.0,
      "end_time": 1485.56
    },
    {
      "text": " traversing a new tree like this, but you have to start printing it. So, 62 will be printed",
      "start_time": 1485.56,
      "end_time": 1490.96
    },
    {
      "text": " again. So, as long as Q's path is a thread path, you have to keep printing it right.",
      "start_time": 1490.96,
      "end_time": 1496.16
    },
    {
      "text": "",
      "start_time": 1496.16,
      "end_time": 1470.0
    },
    {
      "text": " Suppose if this is also not there, this is also not there.",
      "start_time": 1473.76,
      "end_time": null
    },
    {
      "text": " there, then what we have to do is Qs, Qs right thread is true. So, we print piece information,",
      "start_time": 1500.0,
      "end_time": 1507.0
    },
    {
      "text": " 56 is already printed, piece information is printed, again Q is a thread. So, I go here,",
      "start_time": 1507.0,
      "end_time": 1514.88
    },
    {
      "text": " piece information is printed, but this is a new tree. So, I start the traversal. So,",
      "start_time": 1514.88,
      "end_time": 1519.92
    },
    {
      "text": " like this if it is a thread path I keep printing, if it is a new tree I go to the traversal",
      "start_time": 1519.92,
      "end_time": 1525.52
    },
    {
      "text": "",
      "start_time": 1525.52,
      "end_time": 1500.0
    },
    {
      "text": " power. This is how the code has to be written. So, since P is now.",
      "start_time": 1504.48,
      "end_time": null
    },
    {
      "text": " pointing to the right side, I have to check whether q is a right thread or not. So, while",
      "start_time": 1530.0,
      "end_time": 1537.44
    },
    {
      "text": " the q is a right thread as long as the q is pointing to a right thread, q is pointing",
      "start_time": 1537.44,
      "end_time": 1548.84
    },
    {
      "text": " to a right thread and p is also not null, p has moved ahead.",
      "start_time": 1548.84,
      "end_time": 1555.48
    },
    {
      "text": "",
      "start_time": 1555.48,
      "end_time": 1530.0
    },
    {
      "text": " Now, P is moving ahead ok, Q is happening.",
      "start_time": 1534.56,
      "end_time": null
    },
    {
      "text": " having a right thread and P has been said to point to a thread path. So, we have to print",
      "start_time": 1560.0,
      "end_time": 1565.84
    },
    {
      "text": " the P's information, we have to print P's information. Now Q will come to the place",
      "start_time": 1565.84,
      "end_time": 1575.48
    },
    {
      "text": " of P and P will move forward by right side position P because we have passed through",
      "start_time": 1575.48,
      "end_time": 1581.6
    },
    {
      "text": " the thread path. So, whenever I said P to the right side, please note that P might be",
      "start_time": 1581.6,
      "end_time": 1587.92
    },
    {
      "text": "",
      "start_time": 1587.92,
      "end_time": 1560.0
    },
    {
      "text": " be pointing to a new subtree or p.",
      "start_time": 1562.12,
      "end_time": null
    },
    {
      "text": " might be pointing to a thread. If it is pointing to a thread then we continue printing. If",
      "start_time": 1590.0,
      "end_time": 1596.04
    },
    {
      "text": " it is pointing to a new tree, we go back and start the traversal all over like a fursubdree.",
      "start_time": 1596.04,
      "end_time": 1601.9
    },
    {
      "text": " So, Q will be initialized to re-insulized to null and again I keep moving P to the P",
      "start_time": 1601.9,
      "end_time": 1606.76
    },
    {
      "text": " left, P will be motor P left. This is how I keep traversing. So, this I will do as long",
      "start_time": 1606.76,
      "end_time": 1612.46
    },
    {
      "text": "",
      "start_time": 1612.46,
      "end_time": 1590.0
    },
    {
      "text": " as q is also not null. If q also becomes null then the entire tree is completed.",
      "start_time": 1597.36,
      "end_time": null
    },
    {
      "text": " So, then you stop the traversal. While Q is not equal to null, I keep continuing and once",
      "start_time": 1620.0,
      "end_time": 1627.32
    },
    {
      "text": " Q also becomes null, I complete the in-order traversal that is what I am going to do. So,",
      "start_time": 1627.32,
      "end_time": 1632.64
    },
    {
      "text": "",
      "start_time": 1632.64,
      "end_time": 1620.0
    },
    {
      "text": " I will just demonstrate this once again, that reversal path.",
      "start_time": 1634.96,
      "end_time": 1620.0
    },
    {
      "text": " So I take this.",
      "start_time": 1621.0,
      "end_time": null
    },
    {
      "text": " 55, this is 40, this is 78, 62, 89, then this is 30. So, let us try this, this is the",
      "start_time": 1650.0,
      "end_time": 1673.6
    },
    {
      "text": "",
      "start_time": 1673.6,
      "end_time": 1650.0
    },
    {
      "text": " a threaded binary tree. So, I start from here p, q. So, while p naught null, I can",
      "start_time": 1657.0,
      "end_time": null
    },
    {
      "text": " keep coming here. So, Q will come here, P will go to scope. So, then I print Q's information",
      "start_time": 1680.0,
      "end_time": 1686.6
    },
    {
      "text": " 30 is printed, then P is set to right side of Q. Since Q has a thread now, it is time",
      "start_time": 1686.6,
      "end_time": 1692.96
    },
    {
      "text": " for us to print while Q thread is true and P is not null, I print 40 and Q will come",
      "start_time": 1692.96,
      "end_time": 1699.88
    },
    {
      "text": " here and P will go to the thread path again. So, Q's thread path is true again, P is not",
      "start_time": 1699.88,
      "end_time": 1705.72
    },
    {
      "text": "",
      "start_time": 1705.72,
      "end_time": 1680.0
    },
    {
      "text": " So, I print 55. Now, Q will come here.",
      "start_time": 1682.24,
      "end_time": 1687.0
    },
    {
      "text": " and P will go to this. Now Q it is not a thread path, it is like a new tree that we have to",
      "start_time": 1710.0,
      "end_time": 1715.72
    },
    {
      "text": " again look into. So, this is the time at which Q will be set to null because you have to",
      "start_time": 1715.72,
      "end_time": 1721.04
    },
    {
      "text": " start the traversal all over. So, while P left not equal to null Q will come to the",
      "start_time": 1721.04,
      "end_time": 1725.36
    },
    {
      "text": " place of P, P will go here, Q will come to the place of P and P will go out of scope.",
      "start_time": 1725.36,
      "end_time": 1730.36
    },
    {
      "text": " So, once P becomes null it is time for us to print Q. So, 62 is printed. Now P is set",
      "start_time": 1730.36,
      "end_time": 1737.08
    },
    {
      "text": "",
      "start_time": 1737.08,
      "end_time": 1710.0
    },
    {
      "text": " to because we printed 62, P is said to be there.",
      "start_time": 1712.84,
      "end_time": null
    },
    {
      "text": " The right side of P is said to, this is where Q was, P is said to right side of Q. Since",
      "start_time": 1740.0,
      "end_time": 1748.56
    },
    {
      "text": " Q's right thread is true now because there is no child here, Q's right thread is true,",
      "start_time": 1748.56,
      "end_time": 1753.68
    },
    {
      "text": " 78 is going to be printed, Q will come here and P will go here. This is like a new tree.",
      "start_time": 1753.68,
      "end_time": 1759.88
    },
    {
      "text": " So again Q will be initialized to null and we traverse. So while P not null, Q will come",
      "start_time": 1759.88,
      "end_time": 1766.48
    },
    {
      "text": "",
      "start_time": 1766.48,
      "end_time": 1740.0
    },
    {
      "text": " to the place of p and p will become null. So, q 89 is .",
      "start_time": 1743.52,
      "end_time": null
    },
    {
      "text": " printed, 89 is printed and then Q is printed now and P will be said to Q's right side.",
      "start_time": 1770.0,
      "end_time": 1781.92
    },
    {
      "text": " So P has become null now.",
      "start_time": 1781.92,
      "end_time": 1783.74
    },
    {
      "text": " So since Q, P has become null, we have to come out of the printing path and then when",
      "start_time": 1783.74,
      "end_time": 1790.64
    },
    {
      "text": " we go back again Q is said to null, there is P is also null and Q is also null.",
      "start_time": 1790.64,
      "end_time": 1795.36
    },
    {
      "text": " So entire traversal becomes complete here.",
      "start_time": 1795.36,
      "end_time": 1798.24
    },
    {
      "text": "",
      "start_time": 1798.24,
      "end_time": 1770.0
    },
    {
      "text": " So that's how the traversing.",
      "start_time": 1771.32,
      "end_time": null
    },
    {
      "text": " is going to happen in the case of related binary trees.",
      "start_time": 1800.0,
      "end_time": 1803.84
    },
    {
      "text": " So, now let us write the main code, the main part of the code.",
      "start_time": 1803.84,
      "end_time": 1826.96
    },
    {
      "text": "",
      "start_time": 1826.96,
      "end_time": 1800.0
    },
    {
      "text": " I am create an instance of the dream.",
      "start_time": 1802.7,
      "end_time": null
    },
    {
      "text": " instance of the tree. So, I get a tree object, I need to initialize this tree object. So,",
      "start_time": 1830.0,
      "end_time": 1839.84
    },
    {
      "text": " I pass this tree object to the init function where the root is set to null and then I call",
      "start_time": 1839.84,
      "end_time": 1845.88
    },
    {
      "text": " the create function and the tree is going to be created and tree object will hold that",
      "start_time": 1845.88,
      "end_time": 1854.68
    },
    {
      "text": "",
      "start_time": 1854.68,
      "end_time": 1830.0
    },
    {
      "text": " piece address and then I call the inorder traversal on the",
      "start_time": 1835.36,
      "end_time": null
    },
    {
      "text": " this and then I close the main function. So, let us save this, d dot c, files, let us",
      "start_time": 1860.0,
      "end_time": 1883.36
    },
    {
      "text": "",
      "start_time": 1883.36,
      "end_time": 1860.0
    },
    {
      "text": " compile the code, dvd at c.",
      "start_time": 1865.56,
      "end_time": null
    },
    {
      "text": " So, there is an error, let us see temp is a cork mode store incompatible types, just",
      "start_time": 1890.0,
      "end_time": 1904.4
    },
    {
      "text": " a second.",
      "start_time": 1904.4,
      "end_time": 1906.4
    },
    {
      "text": "",
      "start_time": 1906.4,
      "end_time": 1890.0
    },
    {
      "text": " Your node structure is in thread, Apref tree, unit root is set to null, make node of a node start time.",
      "start_time": 1902.0,
      "end_time": 1902.56
    },
    {
      "text": " So, we will here this, p is in the in order function, in order function we have some error",
      "start_time": 1920.0,
      "end_time": 1940.28
    },
    {
      "text": "",
      "start_time": 1940.28,
      "end_time": 1920.0
    },
    {
      "text": " is equal to p right sorry q right, q is right side, this has to be said to not be.",
      "start_time": 1929.72,
      "end_time": null
    },
    {
      "text": " to take care. See that there is a closure problem we will see this is in order. So,",
      "start_time": 1950.0,
      "end_time": 1961.76
    },
    {
      "text": " what create is not closed. So, this I think we are cleared the errors. The error is cleared",
      "start_time": 1961.76,
      "end_time": 1972.76
    },
    {
      "text": "",
      "start_time": 1972.76,
      "end_time": 1950.0
    },
    {
      "text": " Let us see whether it is executing properly. So, 76, 32, I want to add another.",
      "start_time": 1957.2,
      "end_time": null
    },
    {
      "text": " add another 35, add another 57, another 98, 2, another 4.",
      "start_time": 1980.0,
      "end_time": 1991.2
    },
    {
      "text": " And then since it is an in-order iterative traversal, you can see that the code that",
      "start_time": 1991.2,
      "end_time": 1997.52
    },
    {
      "text": " is to be executed is going to create the elements in order.",
      "start_time": 1997.52,
      "end_time": 2002.84
    },
    {
      "text": " As you can see from the code that there is no explicit stacking activity, we have traced",
      "start_time": 2002.84,
      "end_time": 2009.68
    },
    {
      "text": "",
      "start_time": 2009.68,
      "end_time": 1980.0
    },
    {
      "text": " There.",
      "start_time": 1980.5,
      "end_time": null
    },
    {
      "text": " thread path and because of which we have been able to successfully print. So, I will just",
      "start_time": 2010.0,
      "end_time": 2014.88
    },
    {
      "text": " quickly recap the in order traversal. So, I said that P2 root Q is for every separate",
      "start_time": 2014.88,
      "end_time": 2023.6
    },
    {
      "text": " traversal Q will be set to null and I traverse left down when P is pointing to a new tree,",
      "start_time": 2023.6,
      "end_time": 2029.44
    },
    {
      "text": " I will traverse P left down and then when Q is not null I print the information and once the root",
      "start_time": 2029.44,
      "end_time": 2035.68
    },
    {
      "text": "",
      "start_time": 2035.68,
      "end_time": 2010.0
    },
    {
      "text": " node is printed I traverse P to the right side and start all over but",
      "start_time": 2014.22,
      "end_time": null
    },
    {
      "text": " In this case, it may so happen that the Q's right side may be a thread path.",
      "start_time": 2040.0,
      "end_time": 2044.68
    },
    {
      "text": " So if it as long as it is a thread path and P is not null, I keep printing the thread",
      "start_time": 2044.68,
      "end_time": 2049.16
    },
    {
      "text": " path and then move forward there.",
      "start_time": 2049.16,
      "end_time": 2051.24
    },
    {
      "text": " Once the thread path is completed and the recipe is pointing to a new node, new sub tray,",
      "start_time": 2051.24,
      "end_time": 2055.72
    },
    {
      "text": " I have to go back and start over all over again for a new sub tray traverse and again",
      "start_time": 2055.72,
      "end_time": 2060.16
    },
    {
      "text": " same procedure.",
      "start_time": 2060.16,
      "end_time": 2061.16
    },
    {
      "text": " So as long as the entire set of nodes are not completed, that I will get to know from",
      "start_time": 2061.16,
      "end_time": 2065.96
    },
    {
      "text": " P becoming null and Q becoming null, I finish the traverse.",
      "start_time": 2065.96,
      "end_time": 2069.96
    },
    {
      "text": "",
      "start_time": 2069.96,
      "end_time": 2040.0
    },
    {
      "text": " Thank you.",
      "start_time": 2041.0,
      "end_time": null
    },
    {
      "text": " is how the in order traversal for a threaded binary tree is going to be done and because",
      "start_time": 2070.0,
      "end_time": 2075.44
    },
    {
      "text": " of the non-stacking activity, this will be much faster than the in order traversal of",
      "start_time": 2075.44,
      "end_time": 2081.68
    },
    {
      "text": " a binary search tree which did not have threads which made use of the explicit stack.",
      "start_time": 2081.68,
      "end_time": 2087.12
    },
    {
      "text": " And the create function made use of make node and set left set right functions to make sure",
      "start_time": 2087.12,
      "end_time": 2092.0
    },
    {
      "text": " that the nodes are set to the left and right.",
      "start_time": 2092.0,
      "end_time": 2095.0
    },
    {
      "text": " Additionally we have used a R thread field to indicate whether the right pointer is pointing",
      "start_time": 2095.0,
      "end_time": 2099.88
    },
    {
      "text": "",
      "start_time": 2099.88,
      "end_time": 2070.0
    },
    {
      "text": " Thank you.",
      "start_time": 2071.0,
      "end_time": null
    },
    {
      "text": " a thread path or it is pointing to the chain path.",
      "start_time": 2100.0,
      "end_time": 2103.96
    },
    {
      "text": " This is how the threaded binary trace implementation would go in the case of dynamic allocation.",
      "start_time": 2103.96,
      "end_time": 2109.64
    }
  ],
  "transcript_text": " Let me include the files.  So, first and foremost for a threaded binary tree, the node structure that I would like   to have is like that of a binary surgery node structure.  with information field, then I have a pointer to the left and a pointer to the right child.  In addition, I am going to use a field called as R thread.  The reason behind this is something like this.   See what happens.  is when you have a node, let us say this is 2 and this is 4 and this is 3, the address  of this node is 100. So, its left pointer is 100, its right side pointer is 9. Now,   In this case the left pointer is null and right side pointer is null.  is pointing to let us say 200, this is 200 and in this case the right side pointer is  pointing to 400 which is a thread path. Now if when you inspect the right side pointer  in this case and in this case you observe that the right side pointer has 200 is just   number and this right side pointer is 400 which is an  address, 200 is an address, 400 is also an address.  So, by inspecting you would not know whether it is actually pointing to a child or it is  pointing to a thread back thread here.  So, we should have a separate field indicating whether the right side pointer which contains  an address, is it pointing to a child in which case it is not a thread, I will use a field.   In this case 400 is a thread field and therefore, my thread field is a thread field.  thread flag is going to contain one. That is why I said a node structure will have four  fields in it. One is the information field, one is the left pointer, the other one is  the right side pointer. Then you have also the R thread field indicating 0 or 1. 0 indicates  right side pointer pointing to a child, 1 here indicates that it is pointing to a thread.   So that way a node in this case will have 4.  4 feet. Then I am going to create a tree structure, tree data structure which consists of my root   point up. This is my tree.  So, now I will have to initialize the root to null.  So, I am going to call the init function and make the root null.   Then I am going to call the create function.  call the create function. Now, in the create function, let me use a temporary pointer and  also use some more pointers to traverse and I will also use a variable integer wish.   So first and foremost in the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the creation of the  of a binary search tree which is a threaded tree, I need to create the root node. So, for that  I am going to call the make node function. The job of the make node function is to create one node  for us and then return the address. So, I will go ahead and start creating the make node function.   So make node, fill.  create a node. So, I use a temp pointer here as well temp is equal to I will first and  foremost of the responsibility of the make node function is to allocate node 1 node  memory, allocate memory for 1 node and then temps left temps I am going to accept the   information in it.  information in it, I read it into the allocated dynamically allocated node and then I am going  to set see this is a new node that is getting created.  I will set the left pointer to 9, right pointer I will adjust suitably after deciding where  that will go in.   So, right now I will initially when I create the node I am setting it to null and see  Since this new node is going to have a write thread because newly getting created.  So write thread will be set at a pointer later once I know where it has to be created I will  set it to 1.  So return 10 because this node which I created has to be returned back to the caller.  So I am returning.  Since I am returning the nodes address here which is present in 10 I am going to write   Thank you.  this as node star. So, this is going to return a pointer to the node, this is my make node  function. So, when I call the make node function, you know one root node is created, one node  is created and its address is being made to be I mean the address of that such a node  is now present in the root because this is the first node that I am creating. So, once  the root node is created, then I am going to run in iteration to create other nodes.   So, to create other.  node I am going to call the make node again, one more node I call and then this address  now temporarily have put it in temp.  Now I need to make sure that this temp is attached to my existing threaded binary tree  and for this I need to traverse in my tree.  So what I am going to do is for the traversal I will use two pointers Q and P, P will move  forward and Q will traverse behind.   Thank you.  P is said to the root and then while P is not equal to null, P is not equal to null.  As long as P is pointing to nodes, it indicates that we have still not hit a position where  we can insert the new node.  So we keep moving forward.   So Q will come and occupy the place of P and then P has to move forward.  either to the left or right that is based on the Thames information. If M info is less  than P info, P info then we know that P has to move to the left side, P has to move to  the left side. Yes, in this case it is not just P moving to the right side, you have   to see you cannot simply move if it is a thread.  you cannot move back right. If it is only a child, actual child then you have to traverse,  otherwise you cannot move. For example, in this example, so let us say, see in this example,   Suppose I want to 38 is 0.  present, I want to add let us say 40, if I want to add 40, so your P is here, Q is here,  okay.  Now 40 is then Q will come to the place of P, it should be now traverse P, it is not  about traversing P back because we have already finished traversal.  So P is already having a thread now, so we cannot traverse, we have to stop the traversal   If P is having a thread, it is time for us to actually attack.  it here. Suppose if this was not the case, we had like this, let us say, we had like  this already there is a path like this. Now, let us say here, this is already there, I  want to now attach 42, let us say, I want to attach 42, this is a temp. So, how do we   start here. So, initially, Q is equal to Q is equal to Q is equal to Q is equal to Q  is null and p is here. So, 42 is less than 56. So, q will come to the place of this and  p will go forward. p is still not a right thread, is it not? That means you have not  finished the traversal. So, we are yet to complete the traversal. We have not still  found a place for 42. So, 42 is greater than 38. So, q will come to the place of p, q will   come to the place of B and B will go.  forward now because P will move forward now, please note because it is a child because  this P is not a right thread now and 42 is greater than 38, P will move forward.  So when P will move forward to the right side, it will move forward to the right side if  currently P is not a right thread and 42 is greater than 38, P will move forward.  So now Q and P are here.   Now again, so in this case, we have a problem with the  is 42 is greater than, P is still not null, so I am still not completing, I have still  not completed the traversal. So, Q will come to the place of P, but 42 is greater than  40, but does it mean that we have to move P? No, because P is having a right thread  now, you cannot move. So, when P is a right thread, you cannot blindly move P to the right  side, although 42 is greater than 40. So, if P is a right thread, we have to stop, we   know that we have already hit a...  place where 42 has to be attached. So, if P is a right thread then we stop the traversal  and make sure that whatever 40 was pointing now this will be made to point to and then  this P right side will be now pointing to this so that this chain is broken, its R  thread will be made as false and this R thread is true that is how the right side is going  to be attached. So, this is how the threaded binary tree is going to be created. This is   clear if you want to attach something to the right side, what you are going to do is,  whatever this was pointing now with this will start pointing as a thread, this will be made  as a right actual right child. Therefore, the r thread of this will be set to 0 and  r thread of this will be set to 1. This is how I am going to set a new node to the right  side. So, let us continue.  So, what I am going to do is if temp info in this case you can note while p not null   q equal to b if temp in for e.  is less than P in 4, P will move to the left side.  Else, you can't simply move P now to the right side.  We have to check if P has a thread path.  If the thread path is true, if P has a thread path, then I am going to just break from it  because then also I stop the traversal.  So one other condition for which I stop the traversal is P has become null.   Otherwise I will stop the traversal.  for the case of, for the case of P being right-thread. If it is not a right-thread, then I have to  simply move P to the right side because I have to continue with my traversal. So, now when you come  out of the y loop, you know that P would have become null, if P has become null, then you know   that for sure you have to set this new node to the left side of Q.  you have to set it to the left side of Q because you would have said something to the, P would  have become null and you have to set it to the left side of the Q, Q would have come  to the previous.  Yes, it is understood that you are breaking from the while loop because of the thread  path, if P is still not null then P is having a right thread because of the thread path you  are coming out as while loop.   So what I am going to do is I am going to write a text, I am going to write a text,  to setRyche to the right side of p in this case, the new node temp that is what I am  going to do. So, after I am done with one node creation and insertion into the threaded  binary tree, I am going to again ask do you want to add another one or zero to be answering   the query then I will accept it in.  So, I can write this as wish and then I continue.  So as long as there is wish to create node nodes.  So here I need to write now set left and set right functions.   So let us write that point set left, set left node star p comma node star p.  So, what this function does is to set any, I receive two nodes addresses and my job is  to set p to the left of p provided p itself is not null.  So, I am going to check if p is equal to null, I cannot set it, if p itself is null, how  can I set something to the left of p and if p left is already occupied by somebody then   also I am not good to set not equal to 9.  then I cannot set, I will just return. These are some exceptions that I am taking care.  Otherwise I can set to the left of P this T, since I am setting it to the left of P,  so you please note that T's right side, T's right side will be the P itself, this is a  third part that I am creating and also I am making sure now that the T's right thread   is already set to 1 from the initialization itself. So, you need to  take care of setting t right to p which is the in order successor. So, p is the in order  successor for t when you are setting it to f, you can see that. So, that is how the thread   is created. So, we can see that here. So, when you  whenever I create a new node 56, if I set something to the left side of a node 12, this  is P, this is D. So, you can see that in order successor for 12 is 56. So, T's right side  will point to P through the thread path. So, this thread will be set to 1 anyway that is  done in the make node itself. So, that change P's left is T, T's right side is P, this   is how we are going to set.  So, that is what is going to be done.  So, now we will see the function for set write.  In the set write function also I am going to accept two pointers, one to which the node  has to be connected, other one is the new node.   also I will check if p itself is 9.  cannot connect it, so I will just return. Now in this case p is right side is not null,  please note that. Therefore, we have to check if p is right thread, if p is not a right  thread, because only if it is a thread I can connect to the right side. If p is not a right   right, right, right, right, right, right, right, right, right, right, right, right, right,  So, if it is already having a child path then I have to just return ok.  Only if it is a thread then I have to start connecting.  So, whatever piece right side was pointing to now it should be pointed by the piece right  side ok.   p right now should be safely modified to point to this D which is the child.  And T now since P right is now pointing to actual child, P's right thread should be  said to 0, it is no more a thread. T's right thread is anyway positive, so that is fine.  So, let us see through a diagram that why this is going to be that way. So, now you can see,   t, I am going to attach 18 here, this is your t and this is your p.  I am setting something to the right side of P, P and T. So, what I am going to do is whatever  P right side was pointing to the thread, now that has to be captured in T. So, T's right  side should be capturing whatever P's right was pointing to. So, that way this will now  start pointing to this fellow. Now, this has to be broken. So, P's right side should be  T, P's right side and this thread is no more true. So, we have to set it to 0 that is what   any troubles.  So, that is what has been done.  So, here t right is equal to p right and p right is t.  So, that has been done, t right is equal to p right, p right is t, p r third is 0.  So, this is the set right function.  Now, we will look at the traversal.  The main goal for our moving in for a threaded binary tree was to avoid the usage of the   explicit stack and let us see how that can be done now.  the iterative traversal. So, what I am going to do is here is to create again two temporary  pointers to traverse through the tree. So, I am going to set P to the root of the tree  because we have to start the traversal from the root. So, now I am going to keep traversing  as long as I have nodes to be printed. Initially Q is set to null, initially Q is set to null   and you know that this is in order traversal.  And because of which the sequences you have to traverse the left side tree first, then  visit the root and then traverse the right side.  So while P not equal to null, P not equal to null, keep traversing Q and P, Q will come  to the place of P and P will traverse to the left.   So, this will make sure that P is gone out of the scope and Q would be  be at the place where we have to print. So, I will show that. So, in the threaded binary  tree here, we will take the example of a threaded binary tree. I will pick up this 65, 62, 78   then  we have 56 and then 63, then this is 58. So, and this is pointing to this thread and this  is pointing to thread. So, now in this case the way I am going to do is I will start the  traversal P is here Q is initially null. So, while P not null I have to keep traversing   to the left side. So, what happens is q will come here.  P will go here, then P is not null. So, Q will come here, P will go here, P is not null, Q will  come here and P has gone out of scope. So, when P becomes null, you know that you have traversed  down the left side, so that is what has happened. So, you have completely come down to the left.  So, the since P has become null, there is nothing to the left side. So, it indicates that it is   time for us to print the information of Q provided.  added q is not null. So, if q is not null not equal to null, I will print q's information  after printing see left visit the root and then go to the right this is a in order after  printing the root this node now we have to traverse to the right side of the tree. So,  I will set p to the right side of q. So, p will be set to the right side of q this is   So, what I am going to do now ok.  So, that part of the code let us see. So, if q is not equal to 9, then I am going to  set print, print the node because it is time for me to print the q's information   ok and then I am going to make the p point to the right.  side of Q. So, P might be pointing to a new tree, P might be pointing to a thread. So,  we have to find out in this case ok. So, that is what has happened. So, in the example that  I have picked up, the example that I have picked up, P is pointing to a new tree altogether.  See, we might have also taken a node here right, this is let us say 57. So, this is   a sub tree now, this is a sub tree.  we have to now finish this part before we move back to the above one.  So in this case P has been said to the right side, but this is not a thread path.  It is not choose right side if you look at, it is a child path, it is not a thread path  because of which it is a new traversing that we have to make up.  So what happens is it keeps traversing and we print 57 and all that.   Suppose if this were not to be this way, let us say.  If the connection was like this, after completing Q, P will go to the right side of Q. So, P  will be here. In this case Q has a thread path. If it is going back then it is not about  traversing a new tree like this, but you have to start printing it. So, 62 will be printed  again. So, as long as Q's path is a thread path, you have to keep printing it right.   Suppose if this is also not there, this is also not there.  there, then what we have to do is Qs, Qs right thread is true. So, we print piece information,  56 is already printed, piece information is printed, again Q is a thread. So, I go here,  piece information is printed, but this is a new tree. So, I start the traversal. So,  like this if it is a thread path I keep printing, if it is a new tree I go to the traversal   power. This is how the code has to be written. So, since P is now.  pointing to the right side, I have to check whether q is a right thread or not. So, while  the q is a right thread as long as the q is pointing to a right thread, q is pointing  to a right thread and p is also not null, p has moved ahead.   Now, P is moving ahead ok, Q is happening.  having a right thread and P has been said to point to a thread path. So, we have to print  the P's information, we have to print P's information. Now Q will come to the place  of P and P will move forward by right side position P because we have passed through  the thread path. So, whenever I said P to the right side, please note that P might be   be pointing to a new subtree or p.  might be pointing to a thread. If it is pointing to a thread then we continue printing. If  it is pointing to a new tree, we go back and start the traversal all over like a fursubdree.  So, Q will be initialized to re-insulized to null and again I keep moving P to the P  left, P will be motor P left. This is how I keep traversing. So, this I will do as long   as q is also not null. If q also becomes null then the entire tree is completed.  So, then you stop the traversal. While Q is not equal to null, I keep continuing and once  Q also becomes null, I complete the in-order traversal that is what I am going to do. So,   I will just demonstrate this once again, that reversal path.  So I take this.  55, this is 40, this is 78, 62, 89, then this is 30. So, let us try this, this is the   a threaded binary tree. So, I start from here p, q. So, while p naught null, I can  keep coming here. So, Q will come here, P will go to scope. So, then I print Q's information  30 is printed, then P is set to right side of Q. Since Q has a thread now, it is time  for us to print while Q thread is true and P is not null, I print 40 and Q will come  here and P will go to the thread path again. So, Q's thread path is true again, P is not   So, I print 55. Now, Q will come here.  and P will go to this. Now Q it is not a thread path, it is like a new tree that we have to  again look into. So, this is the time at which Q will be set to null because you have to  start the traversal all over. So, while P left not equal to null Q will come to the  place of P, P will go here, Q will come to the place of P and P will go out of scope.  So, once P becomes null it is time for us to print Q. So, 62 is printed. Now P is set   to because we printed 62, P is said to be there.  The right side of P is said to, this is where Q was, P is said to right side of Q. Since  Q's right thread is true now because there is no child here, Q's right thread is true,  78 is going to be printed, Q will come here and P will go here. This is like a new tree.  So again Q will be initialized to null and we traverse. So while P not null, Q will come   to the place of p and p will become null. So, q 89 is .  printed, 89 is printed and then Q is printed now and P will be said to Q's right side.  So P has become null now.  So since Q, P has become null, we have to come out of the printing path and then when  we go back again Q is said to null, there is P is also null and Q is also null.  So entire traversal becomes complete here.   So that's how the traversing.  is going to happen in the case of related binary trees.  So, now let us write the main code, the main part of the code.   I am create an instance of the dream.  instance of the tree. So, I get a tree object, I need to initialize this tree object. So,  I pass this tree object to the init function where the root is set to null and then I call  the create function and the tree is going to be created and tree object will hold that   piece address and then I call the inorder traversal on the  this and then I close the main function. So, let us save this, d dot c, files, let us   compile the code, dvd at c.  So, there is an error, let us see temp is a cork mode store incompatible types, just  a second.   Your node structure is in thread, Apref tree, unit root is set to null, make node of a node start time.  So, we will here this, p is in the in order function, in order function we have some error   is equal to p right sorry q right, q is right side, this has to be said to not be.  to take care. See that there is a closure problem we will see this is in order. So,  what create is not closed. So, this I think we are cleared the errors. The error is cleared   Let us see whether it is executing properly. So, 76, 32, I want to add another.  add another 35, add another 57, another 98, 2, another 4.  And then since it is an in-order iterative traversal, you can see that the code that  is to be executed is going to create the elements in order.  As you can see from the code that there is no explicit stacking activity, we have traced   There.  thread path and because of which we have been able to successfully print. So, I will just  quickly recap the in order traversal. So, I said that P2 root Q is for every separate  traversal Q will be set to null and I traverse left down when P is pointing to a new tree,  I will traverse P left down and then when Q is not null I print the information and once the root   node is printed I traverse P to the right side and start all over but  In this case, it may so happen that the Q's right side may be a thread path.  So if it as long as it is a thread path and P is not null, I keep printing the thread  path and then move forward there.  Once the thread path is completed and the recipe is pointing to a new node, new sub tray,  I have to go back and start over all over again for a new sub tray traverse and again  same procedure.  So as long as the entire set of nodes are not completed, that I will get to know from  P becoming null and Q becoming null, I finish the traverse.   Thank you.  is how the in order traversal for a threaded binary tree is going to be done and because  of the non-stacking activity, this will be much faster than the in order traversal of  a binary search tree which did not have threads which made use of the explicit stack.  And the create function made use of make node and set left set right functions to make sure  that the nodes are set to the left and right.  Additionally we have used a R thread field to indicate whether the right pointer is pointing   Thank you.  a thread path or it is pointing to the chain path.  This is how the threaded binary trace implementation would go in the case of dynamic allocation."
}