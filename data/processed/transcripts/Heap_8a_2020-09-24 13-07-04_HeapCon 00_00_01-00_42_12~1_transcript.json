{
  "video_name": "Heap_8a_2020-09-24 13-07-04_HeapCon 00_00_01-00_42_12~1",
  "video_path": "data/raw/videos/Heap_8a_2020-09-24 13-07-04_HeapCon 00_00_01-00_42_12~1.mkv",
  "duration_seconds": 2531.811,
  "transcript": [
    {
      "text": " Welcome back to PES University's online classes on data structures and its applications.",
      "start_time": 0.0,
      "end_time": 8.24
    },
    {
      "text": " In this session, we will discuss a specialized binary tree called as heap, its definition,",
      "start_time": 8.24,
      "end_time": 15.36
    },
    {
      "text": " examples and implementation.",
      "start_time": 15.36,
      "end_time": 18.4
    },
    {
      "text": " Let's begin.",
      "start_time": 18.4,
      "end_time": 20.4
    },
    {
      "text": " A heap tree is also a binary tree, which means that it will consist of set of nodes along",
      "start_time": 20.4,
      "end_time": 26.92
    },
    {
      "text": "",
      "start_time": 26.92,
      "end_time": 0.0
    },
    {
      "text": " with the key information being present inside the",
      "start_time": 3.0,
      "end_time": null
    },
    {
      "text": " Then apart from this, what else it possesses?",
      "start_time": 30.0,
      "end_time": 35.56
    },
    {
      "text": " It must be because you are not calling it as just plain binary tree, right?",
      "start_time": 35.56,
      "end_time": 39.84
    },
    {
      "text": " So then what else it may possess?",
      "start_time": 39.84,
      "end_time": 42.08
    },
    {
      "text": " Of course, a binary tree must satisfy certain requirements for it to be called as a heap",
      "start_time": 42.08,
      "end_time": 48.64
    },
    {
      "text": " tree.",
      "start_time": 48.64,
      "end_time": 49.64
    },
    {
      "text": " There are basically two requirements.",
      "start_time": 49.64,
      "end_time": 53.36
    },
    {
      "text": " One is called as a shape requirement and the other one is called as a parental dominance",
      "start_time": 53.36,
      "end_time": 58.68
    },
    {
      "text": "",
      "start_time": 58.68,
      "end_time": 30.0
    },
    {
      "text": " requirement.",
      "start_time": 30.5,
      "end_time": null
    },
    {
      "text": " Let us see what they mean. A binary tree is called as a heap tree when a when the tree",
      "start_time": 60.0,
      "end_time": 67.52
    },
    {
      "text": " has fulfilled the shape requirement property. A binary tree must be a complete binary tree",
      "start_time": 67.52,
      "end_time": 75.03999999999999
    },
    {
      "text": " for it to be called as a heap tree in the first place. This is one requirement,",
      "start_time": 75.68,
      "end_time": 79.36
    },
    {
      "text": " this is a partial requirement. There is one more. Just because a complete binary tree we have,",
      "start_time": 79.36,
      "end_time": 85.84
    },
    {
      "text": "",
      "start_time": 85.84,
      "end_time": 60.0
    },
    {
      "text": " you don't call it as heap but that is one of the requirements.",
      "start_time": 64.0,
      "end_time": null
    },
    {
      "text": " then the other requirement is that of the parental dominance property.",
      "start_time": 90.0,
      "end_time": 94.64
    },
    {
      "text": " What do we mean by this?",
      "start_time": 94.64,
      "end_time": 97.12
    },
    {
      "text": " If parent has some key value, then both its children will have information lesser than",
      "start_time": 97.12,
      "end_time": 103.44
    },
    {
      "text": " that of the parent or vice versa.",
      "start_time": 103.44,
      "end_time": 107.2
    },
    {
      "text": " If the parent has some key value, both its children will have information greater than",
      "start_time": 107.2,
      "end_time": 112.4
    },
    {
      "text": " that of the parent.",
      "start_time": 112.4,
      "end_time": 113.92
    },
    {
      "text": " Both are possible.",
      "start_time": 113.92,
      "end_time": 114.92
    },
    {
      "text": "",
      "start_time": 114.92,
      "end_time": 90.0
    },
    {
      "text": " Let's see an example.",
      "start_time": 92.0,
      "end_time": null
    },
    {
      "text": " right 65 at the root, then you have both its children let us say 15 and 35, ok.",
      "start_time": 120.0,
      "end_time": 129.34
    },
    {
      "text": " This satisfies the parental dominance property wherein the parent has 65 and the both its",
      "start_time": 129.34,
      "end_time": 137.84
    },
    {
      "text": " children are 15 and 35 which are lesser than that of 65.",
      "start_time": 137.84,
      "end_time": 142.52
    },
    {
      "text": " This should be satisfied at every level of course.",
      "start_time": 142.52,
      "end_time": 145.76
    },
    {
      "text": "",
      "start_time": 145.76,
      "end_time": 120.0
    },
    {
      "text": " So here let us take 8 and then let us take 7.",
      "start_time": 124.04,
      "end_time": null
    },
    {
      "text": " nothing like the left child should be lesser or right child should be greater. It is between",
      "start_time": 150.0,
      "end_time": 154.8
    },
    {
      "text": " the levels and between the parent and the children. So, the parental dominance says",
      "start_time": 154.8,
      "end_time": 159.86
    },
    {
      "text": " that the parent has key value greater than that of the two children. Here also, so it",
      "start_time": 159.86,
      "end_time": 165.68
    },
    {
      "text": " should be at every level in the binary tree, here 35 is greater than 8 and 7. Therefore,",
      "start_time": 165.68,
      "end_time": 171.56
    },
    {
      "text": "",
      "start_time": 171.56,
      "end_time": 150.0
    },
    {
      "text": " we call such a binary tree see as a heap tree, but of course this is not satisfying the shi-",
      "start_time": 157.76,
      "end_time": 158.76
    },
    {
      "text": " shape requirement, but I am just giving an example of what we mean by parental dominance",
      "start_time": 180.0,
      "end_time": 184.96
    },
    {
      "text": " here.",
      "start_time": 184.96,
      "end_time": 185.96
    },
    {
      "text": " Now, in this case if the parent has the value greater than that of the two children, it",
      "start_time": 185.96,
      "end_time": 193.6
    },
    {
      "text": " is called as a descending heap.",
      "start_time": 193.6,
      "end_time": 196.2
    },
    {
      "text": " It is a descending heap.",
      "start_time": 196.2,
      "end_time": 198.2
    },
    {
      "text": " The vice versa if the as I said the parent may have information lesser than that of the",
      "start_time": 198.2,
      "end_time": 205.0
    },
    {
      "text": "",
      "start_time": 205.0,
      "end_time": 180.0
    },
    {
      "text": " children. Then in which case this kind of a tree is called as an ascending tree.",
      "start_time": 186.88,
      "end_time": null
    },
    {
      "text": " So, both are possible.",
      "start_time": 210.0,
      "end_time": 211.88
    },
    {
      "text": " So in this example, in this definition, it is only written as greater, but vice versa",
      "start_time": 211.88,
      "end_time": 217.84
    },
    {
      "text": " is also possible.",
      "start_time": 217.84,
      "end_time": 219.28
    },
    {
      "text": " The key at each node is lesser than or equal to its children, that is also possible.",
      "start_time": 219.28,
      "end_time": 224.76
    },
    {
      "text": " So, here is the definition of a descending heap.",
      "start_time": 224.76,
      "end_time": 227.8
    },
    {
      "text": " So overall, what we say a binary tree, when do you call it as a heap tree, we will call",
      "start_time": 227.8,
      "end_time": 233.6
    },
    {
      "text": " that as a heap tree if the binary tree is a complete binary tree and it satisfies the",
      "start_time": 233.6,
      "end_time": 239.24
    },
    {
      "text": "",
      "start_time": 239.24,
      "end_time": 210.0
    },
    {
      "text": " parental dog.",
      "start_time": 210.8,
      "end_time": null
    },
    {
      "text": " property. Such a tree is called as a heap tree. Now, when you construct the elements",
      "start_time": 240.0,
      "end_time": 245.74
    },
    {
      "text": " as a heap, then this finds its applications in several of the programs. Like if you want",
      "start_time": 245.74,
      "end_time": 255.18
    },
    {
      "text": " to implement the priority queue, earlier we have discussed in unit 2 a concept called",
      "start_time": 255.18,
      "end_time": 260.58
    },
    {
      "text": " as priority queue and there we had looked at implementation of priority queue using arrays",
      "start_time": 260.58,
      "end_time": 266.62
    },
    {
      "text": "",
      "start_time": 266.62,
      "end_time": 240.0
    },
    {
      "text": " as well as using linked list. But here after .",
      "start_time": 243.32,
      "end_time": null
    },
    {
      "text": " understanding the heaps, once again we will revisit the implementation of priority queue",
      "start_time": 270.0,
      "end_time": 274.76
    },
    {
      "text": " using heap and see how the operations can be performed much more efficiently here than",
      "start_time": 274.76,
      "end_time": 280.84
    },
    {
      "text": " over there, ok.",
      "start_time": 280.84,
      "end_time": 282.52
    },
    {
      "text": " So that is one of the important applications of constructing a heap and using it for the",
      "start_time": 282.52,
      "end_time": 287.88
    },
    {
      "text": " priority queue implementations and then we also can use make use of the heap in order",
      "start_time": 287.88,
      "end_time": 293.36
    },
    {
      "text": " statistics like you want to get the largest element, kth largest element and so on because",
      "start_time": 293.36,
      "end_time": 299.36
    },
    {
      "text": "",
      "start_time": 299.36,
      "end_time": 270.0
    },
    {
      "text": " it meant it.",
      "start_time": 270.64,
      "end_time": null
    },
    {
      "text": " some order here, such order statistics also we can make use of the heap data structure.",
      "start_time": 300.0,
      "end_time": 306.36
    },
    {
      "text": " So it finds its applications in several of these programs like in draft traversals and",
      "start_time": 306.36,
      "end_time": 311.52
    },
    {
      "text": " so on and that is why it is a very important data structure to study.",
      "start_time": 311.52,
      "end_time": 316.96
    },
    {
      "text": " So let us continue.",
      "start_time": 316.96,
      "end_time": 318.28
    },
    {
      "text": " So we have understood now the definition of a heap tree.",
      "start_time": 318.28,
      "end_time": 322.3
    },
    {
      "text": " So how do we define the, so let us understand this through an example first.",
      "start_time": 322.3,
      "end_time": 329.44
    },
    {
      "text": "",
      "start_time": 329.44,
      "end_time": 300.0
    },
    {
      "text": " We",
      "start_time": 302.0,
      "end_time": null
    },
    {
      "text": " what is a heap and what is not a heap. So, here is an example of a heap because you can see that",
      "start_time": 330.0,
      "end_time": 335.36
    },
    {
      "text": " both the properties are satisfied. Here in this case example the first property the tree shape",
      "start_time": 335.36,
      "end_time": 343.28
    },
    {
      "text": " requirement property is not satisfied because there is no node here it is not a complete binary tree.",
      "start_time": 343.28,
      "end_time": 349.44
    },
    {
      "text": " This is a complete binary tree only here to the last rightmost we do not have a leaf but otherwise",
      "start_time": 350.16,
      "end_time": 356.0
    },
    {
      "text": "",
      "start_time": 356.0,
      "end_time": 330.0
    },
    {
      "text": " is it satisfying the complete binary tree and the second.",
      "start_time": 334.04,
      "end_time": null
    },
    {
      "text": " property which is a parental dominance. See at 10, 5, 7 level it is satisfied, 7, 1 level",
      "start_time": 360.0,
      "end_time": 365.96
    },
    {
      "text": " also it is satisfied, but it is not getting satisfied at this level and that is why it",
      "start_time": 365.96,
      "end_time": 370.84
    },
    {
      "text": " is not a heap. Whereas for this both the shape requirement as well as the parental dominance",
      "start_time": 370.84,
      "end_time": 378.12
    },
    {
      "text": " are satisfied and therefore, this is an example of a heap.",
      "start_time": 378.12,
      "end_time": 383.8
    },
    {
      "text": "",
      "start_time": 383.8,
      "end_time": 360.0
    },
    {
      "text": " set there ok. Now, let us look at the properties related to heap. Since,",
      "start_time": 366.0,
      "end_time": null
    },
    {
      "text": " this heap is a complete binary tree, you will have nodes at every level and a nonlinearity",
      "start_time": 390.0,
      "end_time": 395.66
    },
    {
      "text": " has been brought in.",
      "start_time": 395.66,
      "end_time": 396.66
    },
    {
      "text": " Let us say heap has a height hedge, total height hedge.",
      "start_time": 396.66,
      "end_time": 400.72
    },
    {
      "text": " So and with total number of nodes being n, so because they are distributed across in",
      "start_time": 400.72,
      "end_time": 406.56
    },
    {
      "text": " a nonlinear fashion, both sides, the height of the tree can be proved as log into base",
      "start_time": 406.56,
      "end_time": 412.6
    },
    {
      "text": " 2.",
      "start_time": 412.6,
      "end_time": 413.6
    },
    {
      "text": " So this is one of the important properties of such a tree.",
      "start_time": 413.6,
      "end_time": 417.08
    },
    {
      "text": "",
      "start_time": 417.08,
      "end_time": 390.0
    },
    {
      "text": " The second property as you know just now given in the demo.",
      "start_time": 392.92,
      "end_time": null
    },
    {
      "text": " definition, the root of the heap will always have the largest element in the case of descending",
      "start_time": 420.0,
      "end_time": 425.82
    },
    {
      "text": " heap, otherwise it will have the smallest element in the case of ascending heap.",
      "start_time": 425.82,
      "end_time": 430.84
    },
    {
      "text": " Then the binary tree if it to be called as a heap, it is not just enough that it is satisfied",
      "start_time": 430.84,
      "end_time": 437.2
    },
    {
      "text": " at the root level, but it has to be at every level, even the below descendants must be",
      "start_time": 437.2,
      "end_time": 442.8
    },
    {
      "text": " heap.",
      "start_time": 442.8,
      "end_time": 443.8
    },
    {
      "text": " So, that is the next property, a node of a heap considered with all its descendants",
      "start_time": 443.8,
      "end_time": 448.6
    },
    {
      "text": "",
      "start_time": 448.6,
      "end_time": 420.0
    },
    {
      "text": " is also a heap.",
      "start_time": 421.0,
      "end_time": null
    },
    {
      "text": " Now, how do you place this kind of a heat tree in the memory?",
      "start_time": 450.0,
      "end_time": 457.04
    },
    {
      "text": " Are we going to go for dynamic allocation or are you going to go for array implementation?",
      "start_time": 457.04,
      "end_time": 462.56
    },
    {
      "text": " We have seen both the implementations while discussing the binary surgery.",
      "start_time": 462.56,
      "end_time": 470.64
    },
    {
      "text": " There we went ahead and implemented the binary surgery using both dynamic and as well as",
      "start_time": 470.64,
      "end_time": 476.8
    },
    {
      "text": " implicit array representation.",
      "start_time": 476.8,
      "end_time": 478.88
    },
    {
      "text": "",
      "start_time": 478.88,
      "end_time": 450.0
    },
    {
      "text": " So there we have studied.",
      "start_time": 451.12,
      "end_time": null
    },
    {
      "text": " the way the housing of these nodes are going to be done in the array.",
      "start_time": 480.0,
      "end_time": 485.04
    },
    {
      "text": " So here we are talking about a complete binary tree.",
      "start_time": 485.04,
      "end_time": 488.84
    },
    {
      "text": " Because it is a complete binary tree, we can also arrange these nodes in the form of an",
      "start_time": 488.84,
      "end_time": 494.52
    },
    {
      "text": " array where you can arrange these nodes from top down to left to right as we saw in the",
      "start_time": 494.52,
      "end_time": 499.52
    },
    {
      "text": " binary search tree.",
      "start_time": 499.52,
      "end_time": 501.04
    },
    {
      "text": " So you can see that these nodes can be arranged in the, I will take this example binary search",
      "start_time": 501.04,
      "end_time": 507.04
    },
    {
      "text": " the heap tree.",
      "start_time": 507.04,
      "end_time": 508.48
    },
    {
      "text": "",
      "start_time": 508.48,
      "end_time": 480.0
    },
    {
      "text": " So this can be placed at position.",
      "start_time": 482.0,
      "end_time": null
    },
    {
      "text": " This can be at position 2, this can be at 3, this will be at position 4, this is 5,",
      "start_time": 510.0,
      "end_time": 517.0
    },
    {
      "text": " 6.",
      "start_time": 517.0,
      "end_time": 518.0
    },
    {
      "text": " So, you can place this kind of a heap tree in the form of an implicit array representation",
      "start_time": 518.0,
      "end_time": 525.64
    },
    {
      "text": " that we have seen and we can place this 10 here, then 5 here.",
      "start_time": 525.64,
      "end_time": 531.88
    },
    {
      "text": " So, top down left to right fashion and I have assumed now in this example, I have assumed",
      "start_time": 531.88,
      "end_time": 537.76
    },
    {
      "text": "",
      "start_time": 537.76,
      "end_time": 510.0
    },
    {
      "text": " the position to start from 1.",
      "start_time": 512.0,
      "end_time": null
    },
    {
      "text": " And we have seen earlier that either you can start from position 1 or you can start from",
      "start_time": 540.0,
      "end_time": 544.6
    },
    {
      "text": " position 0.",
      "start_time": 544.6,
      "end_time": 546.32
    },
    {
      "text": " If you start from position 1, the left side will be at position.",
      "start_time": 546.32,
      "end_time": 549.68
    },
    {
      "text": " If this position is k, this will be at position 2k and this will be at position 2k plus 1.",
      "start_time": 549.68,
      "end_time": 556.4
    },
    {
      "text": " Like that it is going to be satisfied at every position.",
      "start_time": 556.4,
      "end_time": 560.44
    },
    {
      "text": " So you have 5 and then you are going to place 7 and then we have 4 and then we have 2 and",
      "start_time": 560.44,
      "end_time": 567.12
    },
    {
      "text": " then 1.",
      "start_time": 567.12,
      "end_time": 568.6
    },
    {
      "text": "",
      "start_time": 568.6,
      "end_time": 540.0
    },
    {
      "text": " So this is so you can see.",
      "start_time": 541.44,
      "end_time": null
    },
    {
      "text": " that the normal issues that we had with array implementation or intermixing of vacant space",
      "start_time": 570.0,
      "end_time": 576.72
    },
    {
      "text": " with the actual space that does not arise here because it is a complete binary tree.",
      "start_time": 576.72,
      "end_time": 583.2
    },
    {
      "text": " All these positions are free.",
      "start_time": 583.2,
      "end_time": 584.72
    },
    {
      "text": " So since all and only if there are vacant positions only towards the end they are there.",
      "start_time": 584.72,
      "end_time": 589.16
    },
    {
      "text": " So intermixed of space vacant space and field space that kind of an issue does not arise",
      "start_time": 589.16,
      "end_time": 595.16
    },
    {
      "text": " here.",
      "start_time": 595.16,
      "end_time": 596.16
    },
    {
      "text": "",
      "start_time": 596.16,
      "end_time": 570.0
    },
    {
      "text": " it is nice to have an array presentation because it is a",
      "start_time": 573.84,
      "end_time": null
    },
    {
      "text": " implicit representation and we do not store the addresses explicitly, it is easier to",
      "start_time": 600.0,
      "end_time": 605.2
    },
    {
      "text": " operate the tree if this heap is housed in an array.",
      "start_time": 605.2,
      "end_time": 609.12
    },
    {
      "text": " So, this is how we are going to construct the heap by placing the elements into an array",
      "start_time": 609.12,
      "end_time": 616.08
    },
    {
      "text": " instead of the dynamic implementation.",
      "start_time": 616.08,
      "end_time": 619.44
    },
    {
      "text": " So, that is the fourth property that is being mentioned here.",
      "start_time": 619.44,
      "end_time": 623.28
    },
    {
      "text": " So, you can see that heap can be implemented as an array by recording its elements in the",
      "start_time": 623.28,
      "end_time": 628.32
    },
    {
      "text": "",
      "start_time": 628.32,
      "end_time": 600.0
    },
    {
      "text": " top room and let's do",
      "start_time": 603.44,
      "end_time": null
    },
    {
      "text": " right fashion. So, you can decide on whether to use the 0th location or not. So, in such",
      "start_time": 630.0,
      "end_time": 636.88
    },
    {
      "text": " a representation what is going to happen? So, if you have a tree, if you have a tree",
      "start_time": 636.88,
      "end_time": 644.8
    },
    {
      "text": "",
      "start_time": 644.8,
      "end_time": 630.0
    },
    {
      "text": " Okay, then 10, then you have 12, then 9, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,",
      "start_time": 658.92,
      "end_time": null
    },
    {
      "text": " 22 like this let us say I have considered some six nodes assume 25. So, now this is an ascending",
      "start_time": 660.0,
      "end_time": 671.2
    },
    {
      "text": " heap. Now in this case there are six nodes totally. So, n is equal to 6. So, you can see that",
      "start_time": 671.2,
      "end_time": 677.76
    },
    {
      "text": " the nodes which are having children this node, this node and this node. So, 1, 2 and 3 and 4, 5,",
      "start_time": 679.76,
      "end_time": 687.44
    },
    {
      "text": "",
      "start_time": 687.44,
      "end_time": 660.0
    },
    {
      "text": " six onwards, they are just leaves.",
      "start_time": 662.0,
      "end_time": null
    },
    {
      "text": " So, n by 2 flow those many positions 6 by 2 in this case 3, these are the parental positions.",
      "start_time": 690.0,
      "end_time": 699.28
    },
    {
      "text": " So, these are the parental positions 1, 2, 3 and the subsequent next n by 2 positions",
      "start_time": 699.28,
      "end_time": 705.48
    },
    {
      "text": " are 4, 5, 6 which are the child positions, you can observe that.",
      "start_time": 705.48,
      "end_time": 710.48
    },
    {
      "text": " So, this property we will make use of while we construct the heap.",
      "start_time": 710.48,
      "end_time": 714.48
    },
    {
      "text": " So, keep this point in mind.",
      "start_time": 714.48,
      "end_time": 716.24
    },
    {
      "text": "",
      "start_time": 716.24,
      "end_time": 690.0
    },
    {
      "text": " So, in such a representation you can see that the parental.",
      "start_time": 693.76,
      "end_time": null
    },
    {
      "text": " nodes will be in the first n by 2 positions and the leaf will be occupying the last n",
      "start_time": 720.0,
      "end_time": 724.76
    },
    {
      "text": " by 2 positions. And you also know the property that if the child is at position i, then the",
      "start_time": 724.76,
      "end_time": 732.68
    },
    {
      "text": " left child will be at position 2i and 2i plus 1 if we start 1, otherwise if we start from",
      "start_time": 732.68,
      "end_time": 738.56
    },
    {
      "text": " 0 it will be at 2i plus 1 and 2i plus 2. So, that is the next representation that we are",
      "start_time": 738.56,
      "end_time": 744.68
    },
    {
      "text": "",
      "start_time": 744.68,
      "end_time": 720.0
    },
    {
      "text": " talking about. So, let us move on. So, now we will see the edge.",
      "start_time": 725.32,
      "end_time": null
    },
    {
      "text": " example of how to construct a bottom up heap for this kind of elements. Let us say these",
      "start_time": 750.0,
      "end_time": 757.36
    },
    {
      "text": " elements are right now stored in an array. So, let us consider an array, all these elements",
      "start_time": 757.36,
      "end_time": 764.4
    },
    {
      "text": " are stored in the array in this manner 25, 57 and then 48, 37, 12, 92 and then 86 and",
      "start_time": 764.4,
      "end_time": 776.8
    },
    {
      "text": "",
      "start_time": 776.8,
      "end_time": 750.0
    },
    {
      "text": " So, they are presently in the form of a .",
      "start_time": 751.0,
      "end_time": 752.0
    },
    {
      "text": " .",
      "start_time": 752.0,
      "end_time": 753.0
    },
    {
      "text": " an array, but this is only a binary tree now as of now.",
      "start_time": 780.0,
      "end_time": 785.8
    },
    {
      "text": " So, if you look at the pictorial representation, right now the tree is present in an array",
      "start_time": 785.8,
      "end_time": 791.84
    },
    {
      "text": " in this form and pictorially this is how this particular tree is looking like.",
      "start_time": 791.84,
      "end_time": 797.56
    },
    {
      "text": " Now, you cannot leave it at that because we have to now convert this into a heap with",
      "start_time": 797.56,
      "end_time": 802.76
    },
    {
      "text": " the given elements we are expected to convert this tree into a heap tree.",
      "start_time": 802.76,
      "end_time": 807.24
    },
    {
      "text": "",
      "start_time": 807.24,
      "end_time": 780.0
    },
    {
      "text": " But as it is, is it a heap? That is what we have to look at.",
      "start_time": 781.48,
      "end_time": 782.56
    },
    {
      "text": " So, now let us look at, let us say I am interested in constructing a descending heap, descending",
      "start_time": 810.0,
      "end_time": 816.92
    },
    {
      "text": " heap.",
      "start_time": 816.92,
      "end_time": 817.92
    },
    {
      "text": " So, let us say whether this is following the property of the descending heap.",
      "start_time": 817.92,
      "end_time": 821.2
    },
    {
      "text": " So, the very first itself is not, the 25 and 57 is not a descending heap.",
      "start_time": 821.2,
      "end_time": 827.68
    },
    {
      "text": " Here also you can, here it is possible and here it is again not a descending heap.",
      "start_time": 827.68,
      "end_time": 832.64
    },
    {
      "text": " So, overall it is not satisfying the descending heap principle at every level.",
      "start_time": 832.64,
      "end_time": 836.88
    },
    {
      "text": "",
      "start_time": 836.88,
      "end_time": 810.0
    },
    {
      "text": " So, we will have to find out whether at every place",
      "start_time": 813.1,
      "end_time": null
    },
    {
      "text": " whether the tree is satisfying descending heap and overall whether this is a heap tree,",
      "start_time": 840.0,
      "end_time": 845.44
    },
    {
      "text": " okay. In terms of the shape requirement, yes, of course, it is a complete binary tree,",
      "start_time": 845.44,
      "end_time": 849.76
    },
    {
      "text": " but in terms of the parental dominance property, this is not satisfying.",
      "start_time": 849.76,
      "end_time": 855.6
    },
    {
      "text": " So, we need to look at how this can be modified, the elements can be moved around",
      "start_time": 855.6,
      "end_time": 861.76
    },
    {
      "text": " to make sure that a heap is constructed, that is our motivation here. So, and also we will see",
      "start_time": 861.76,
      "end_time": 867.28
    },
    {
      "text": "",
      "start_time": 867.28,
      "end_time": 840.0
    },
    {
      "text": " how much time requirement is needed.",
      "start_time": 842.36,
      "end_time": null
    },
    {
      "text": " And the way we are going to rearrange these elements to make it into a heap tree, for",
      "start_time": 870.0,
      "end_time": 876.88
    },
    {
      "text": " that the methodology that we I am demonstrating now here is a bottom up approach and subsequently",
      "start_time": 876.88,
      "end_time": 883.2
    },
    {
      "text": " we will also see how a top down approach can be used for construction of the heap.",
      "start_time": 883.2,
      "end_time": 888.64
    },
    {
      "text": " So, first let us look at the bottom up approach.",
      "start_time": 888.64,
      "end_time": 892.12
    },
    {
      "text": " In the bottom up approach what we are going to do is to construct one heap at a time which",
      "start_time": 892.12,
      "end_time": 898.88
    },
    {
      "text": "",
      "start_time": 898.88,
      "end_time": 870.0
    },
    {
      "text": " is a suppree.",
      "start_time": 870.88,
      "end_time": null
    },
    {
      "text": " And for that I am going to consider the last parent that is present to the first parent.",
      "start_time": 900.0,
      "end_time": 906.92
    },
    {
      "text": " So you can see that there are 8 nodes here, okay.",
      "start_time": 906.92,
      "end_time": 911.6
    },
    {
      "text": " So there are 8 nodes and you can see the last parent will be deciding at position 4.",
      "start_time": 911.6,
      "end_time": 918.24
    },
    {
      "text": " So 8 by 2 which is 4, n by 2 positions.",
      "start_time": 918.24,
      "end_time": 921.44
    },
    {
      "text": " Parental positions will be starting from 1 to n by 2, right.",
      "start_time": 921.44,
      "end_time": 925.36
    },
    {
      "text": " So the last parent will be at position 4 if there are 8 nodes.",
      "start_time": 925.36,
      "end_time": 929.24
    },
    {
      "text": "",
      "start_time": 929.24,
      "end_time": 900.0
    },
    {
      "text": " The war?",
      "start_time": 900.84,
      "end_time": null
    },
    {
      "text": " this type of construction does is in order to convert this given binary tree into a heap,",
      "start_time": 930.0,
      "end_time": 937.2
    },
    {
      "text": " it uses a bottom up approach to make sure that the heap is constructed.",
      "start_time": 937.2,
      "end_time": 945.32
    },
    {
      "text": " So what do we mean by this?",
      "start_time": 945.32,
      "end_time": 946.8
    },
    {
      "text": " We know that the first parent is starting at position 4.",
      "start_time": 946.8,
      "end_time": 951.64
    },
    {
      "text": " You can see that remaining questions are all leaves.",
      "start_time": 951.64,
      "end_time": 954.44
    },
    {
      "text": " So I am going to start from this position and I am going to consider this subtree here",
      "start_time": 954.44,
      "end_time": 959.68
    },
    {
      "text": "",
      "start_time": 959.68,
      "end_time": 930.0
    },
    {
      "text": " And I",
      "start_time": 932.0,
      "end_time": null
    },
    {
      "text": " I am going to see whether this is already a heap or not.",
      "start_time": 960.0,
      "end_time": 963.6
    },
    {
      "text": " So here this part I am going to convert it into heap.",
      "start_time": 963.6,
      "end_time": 967.2
    },
    {
      "text": " Is that clear?",
      "start_time": 967.2,
      "end_time": 969.44
    },
    {
      "text": " Now after I consider this, this part is done let us say.",
      "start_time": 969.44,
      "end_time": 973.84
    },
    {
      "text": " Now I go to the next parent in the sequence and with respect to this parent whether the",
      "start_time": 973.84,
      "end_time": 980.28
    },
    {
      "text": " heap property is satisfied or not I am going to consider that.",
      "start_time": 980.28,
      "end_time": 983.8
    },
    {
      "text": " If that is not satisfied I am going to adjust it otherwise I will leave it as it is.",
      "start_time": 983.8,
      "end_time": 988.96
    },
    {
      "text": "",
      "start_time": 988.96,
      "end_time": 960.0
    },
    {
      "text": " I will consider the next video.",
      "start_time": 961.0,
      "end_time": null
    },
    {
      "text": " parent. When I consider the next parent, this whole thing has to be considered, please note",
      "start_time": 990.0,
      "end_time": 995.4
    },
    {
      "text": " that ok. So, I am going to see with reference to this parent whether the entire subtree is a heap",
      "start_time": 995.4,
      "end_time": 1001.72
    },
    {
      "text": " or not. Once that is done, then I will go to this. With respect to this, see what happens is",
      "start_time": 1001.72,
      "end_time": 1006.88
    },
    {
      "text": " there will be only few moments that will be required because you are already modifying these",
      "start_time": 1006.88,
      "end_time": 1012.08
    },
    {
      "text": " two. So, there will not be much movement here ok. The idea is to make it in a quick time. You",
      "start_time": 1012.08,
      "end_time": 1018.72
    },
    {
      "text": "",
      "start_time": 1018.72,
      "end_time": 990.0
    },
    {
      "text": " are given a sequence of a...",
      "start_time": 991.28,
      "end_time": null
    },
    {
      "text": " elements and these elements are right now in the form of a binary tree, general binary",
      "start_time": 1020.0,
      "end_time": 1025.02
    },
    {
      "text": " tree. How do I modify these elements such that they form a descending heap? That is",
      "start_time": 1025.02,
      "end_time": 1029.86
    },
    {
      "text": " the idea. So, that is known as a heap tree. So, with respect to this tree, the whole subtree",
      "start_time": 1029.86,
      "end_time": 1035.48
    },
    {
      "text": " must be satisfying the heap. That is how I am going to rearrange. So, let us see how",
      "start_time": 1035.48,
      "end_time": 1040.06
    },
    {
      "text": " this whole thing is to be carried out. So, as I said, first we will start with at k equal",
      "start_time": 1040.06,
      "end_time": 1047.42
    },
    {
      "text": "",
      "start_time": 1047.42,
      "end_time": 1020.0
    },
    {
      "text": " to 4, the value is 37.",
      "start_time": 1022.44,
      "end_time": null
    },
    {
      "text": " Now, this 37, can it be there itself is this level satisfying the heap or not is what we",
      "start_time": 1050.0,
      "end_time": 1059.24
    },
    {
      "text": " have to consider.",
      "start_time": 1059.24,
      "end_time": 1060.24
    },
    {
      "text": " Now, for that 37 right now is having only one child.",
      "start_time": 1060.24,
      "end_time": 1064.28
    },
    {
      "text": " It does see what we said in the parental dominance property is that both its children must be",
      "start_time": 1064.28,
      "end_time": 1069.64
    },
    {
      "text": " having value lesser than that of the root because I am talking about descending heap.",
      "start_time": 1069.64,
      "end_time": 1073.96
    },
    {
      "text": " But in this case what is happening is there is only one child.",
      "start_time": 1073.96,
      "end_time": 1076.88
    },
    {
      "text": "",
      "start_time": 1076.88,
      "end_time": 1050.0
    },
    {
      "text": " So, we will have to just compare it with this child, ok.",
      "start_time": 1052.92,
      "end_time": null
    },
    {
      "text": " So, in the absence of both the children being present, all that we need to do is to compare",
      "start_time": 1080.0,
      "end_time": 1085.2
    },
    {
      "text": " 33 and 37.",
      "start_time": 1085.2,
      "end_time": 1087.2
    },
    {
      "text": " Now, it is so happening that already the parent has higher value than the child.",
      "start_time": 1087.2,
      "end_time": 1092.0
    },
    {
      "text": " So, at this point, there is parental dominance already happening.",
      "start_time": 1092.0,
      "end_time": 1096.0
    },
    {
      "text": " So, there is nothing that needs to be moved and the tree remains the same after this comparison.",
      "start_time": 1096.0,
      "end_time": 1101.4
    },
    {
      "text": " So, there is no change at all.",
      "start_time": 1101.4,
      "end_time": 1103.36
    },
    {
      "text": " Now, let us move on to the next position.",
      "start_time": 1103.36,
      "end_time": 1106.2
    },
    {
      "text": "",
      "start_time": 1106.2,
      "end_time": 1080.0
    },
    {
      "text": " Now in the next one we are having",
      "start_time": 1083.84,
      "end_time": null
    },
    {
      "text": " the next parent at position 48. So, we have to consider this subtree to find out, figure",
      "start_time": 1110.0,
      "end_time": 1115.82
    },
    {
      "text": " out whether the heap is present here or not. So, definitely not because we are talking",
      "start_time": 1115.82,
      "end_time": 1122.24
    },
    {
      "text": " about descending heap. So, we have 48 as the parent and 90 to 86 as its children. So,",
      "start_time": 1122.24,
      "end_time": 1130.72
    },
    {
      "text": " definitely it is not satisfying the parental dominance property and therefore, we have",
      "start_time": 1130.72,
      "end_time": 1136.0
    },
    {
      "text": "",
      "start_time": 1136.0,
      "end_time": 1110.0
    },
    {
      "text": " to convert this into a heat now. So in order to do that first thing",
      "start_time": 1115.76,
      "end_time": null
    },
    {
      "text": " that I need to do is now which child's value that I need to move up that is what we have",
      "start_time": 1140.0,
      "end_time": 1145.76
    },
    {
      "text": " to look at.",
      "start_time": 1145.76,
      "end_time": 1146.92
    },
    {
      "text": " So here 92 is on the left side, 86 is on the right side, these are the two children of",
      "start_time": 1146.92,
      "end_time": 1152.68
    },
    {
      "text": " 48.",
      "start_time": 1152.68,
      "end_time": 1154.16
    },
    {
      "text": " So between the two children whichever child has higher value that value has to be moved",
      "start_time": 1154.16,
      "end_time": 1159.8
    },
    {
      "text": " up is that clear?",
      "start_time": 1159.8,
      "end_time": 1161.36
    },
    {
      "text": " So that is what we have to look at.",
      "start_time": 1161.36,
      "end_time": 1163.68
    },
    {
      "text": "",
      "start_time": 1163.68,
      "end_time": 1140.0
    },
    {
      "text": " So first my comparison is with respect to 92 and 86 ok and in between the 90 and 86 and the 90 and 86 and the 90 and 86 and the 90 and 86 and the 86 and the 86 and the 86",
      "start_time": 1147.0,
      "end_time": 1154.0
    },
    {
      "text": " 92 and 86, 92 is higher. So, if at all I am planning to move the or the swap the 2 it",
      "start_time": 1170.0,
      "end_time": 1178.56
    },
    {
      "text": " is between 48 and 92. So, these 2 I am going to swap and then I am going to construct the",
      "start_time": 1178.56,
      "end_time": 1186.08
    },
    {
      "text": " heap at this point. So, you can see that at this point the heap is constructed. At this",
      "start_time": 1186.08,
      "end_time": 1192.96
    },
    {
      "text": " point also it is done, at this point also it is done now. So, we have to now move on",
      "start_time": 1192.96,
      "end_time": 1197.4
    },
    {
      "text": "",
      "start_time": 1197.4,
      "end_time": 1170.0
    },
    {
      "text": " to this position ok.",
      "start_time": 1172.12,
      "end_time": null
    },
    {
      "text": " here 57 again both its children are compared. When you compare both its children say we",
      "start_time": 1200.0,
      "end_time": 1206.7
    },
    {
      "text": " start from here please note 57 both its children are compared in this case there is no problem",
      "start_time": 1206.7,
      "end_time": 1213.76
    },
    {
      "text": " at all see below case it is already done. So, now you have to compare here 57 is compared",
      "start_time": 1213.76,
      "end_time": 1219.14
    },
    {
      "text": " with 37 and 12. So, 37 and 12 both are smaller so no change is going to happen. So, this",
      "start_time": 1219.14,
      "end_time": 1225.82
    },
    {
      "text": "",
      "start_time": 1225.82,
      "end_time": 1200.0
    },
    {
      "text": " all fine okay so that there is no",
      "start_time": 1205.76,
      "end_time": null
    },
    {
      "text": " in the tree, it is already a heap. Next, let us consider 25, that is the last one.",
      "start_time": 1230.0,
      "end_time": 1236.16
    },
    {
      "text": " So, now, we have to start from here. We have to see, please note that this is a heap now,",
      "start_time": 1236.16,
      "end_time": 1245.56
    },
    {
      "text": " 37, 33, that is a heap, this is also a heap, this whole thing is also a heap. Now, the",
      "start_time": 1245.56,
      "end_time": 1250.96
    },
    {
      "text": " only thing that is left is with respect to this level, we have to find out if it is a",
      "start_time": 1250.96,
      "end_time": 1255.96
    },
    {
      "text": "",
      "start_time": 1255.96,
      "end_time": 1230.0
    },
    {
      "text": " So, 25s both children are first compared.",
      "start_time": 1234.08,
      "end_time": null
    },
    {
      "text": " between 57 and 92, 92 is greater. So, 92 has to move up. Now, when 92 moves up and 25",
      "start_time": 1260.0,
      "end_time": 1268.44
    },
    {
      "text": " comes here, now again you cannot stop at that. See, you have to with respect to this the",
      "start_time": 1268.44,
      "end_time": 1274.76
    },
    {
      "text": " whole thing has to be the heap. So, when 25 comes down again between the two children",
      "start_time": 1274.76,
      "end_time": 1279.72
    },
    {
      "text": " 86 is higher. So, 86 will move up and then 25 will move down. So, 92 and 25 are swapped",
      "start_time": 1279.72,
      "end_time": 1286.8
    },
    {
      "text": "",
      "start_time": 1286.8,
      "end_time": 1260.0
    },
    {
      "text": " and then 25 and 86 are swapped.",
      "start_time": 1263.0,
      "end_time": null
    },
    {
      "text": " in the next comparison and then finally you will be in a question to say that this is",
      "start_time": 1290.0,
      "end_time": 1295.28
    },
    {
      "text": " a heap.",
      "start_time": 1295.28,
      "end_time": 1296.28
    },
    {
      "text": " So, 25 and 86 are compared here and then this whole thing heap is constructed.",
      "start_time": 1296.28,
      "end_time": 1301.4
    },
    {
      "text": " So, now we have the entire heap being constructed starting from this.",
      "start_time": 1301.4,
      "end_time": 1305.84
    },
    {
      "text": " So initially the array had this.",
      "start_time": 1305.84,
      "end_time": 1308.16
    },
    {
      "text": " Now once the heap is constructed, so your array is going to contain 92 at the first",
      "start_time": 1308.16,
      "end_time": 1312.8
    },
    {
      "text": " position, 57 at the second, 86, 37, 12, 48, 25 and 33.",
      "start_time": 1312.8,
      "end_time": 1318.64
    },
    {
      "text": "",
      "start_time": 1318.64,
      "end_time": 1290.0
    },
    {
      "text": " So this is how our...",
      "start_time": 1291.36,
      "end_time": null
    },
    {
      "text": " original tree which was in this manner has been reformulated, we heapified and we have",
      "start_time": 1320.0,
      "end_time": 1327.04
    },
    {
      "text": " constructed a heap out of the given set of elements and we have placed them in an array.",
      "start_time": 1327.04,
      "end_time": 1332.76
    },
    {
      "text": " So this is the way in which the bottom up approach is going to work, is that clear?",
      "start_time": 1332.76,
      "end_time": 1339.44
    },
    {
      "text": " So this was the original tree and this is the bottom up heap constructed.",
      "start_time": 1339.44,
      "end_time": 1344.28
    },
    {
      "text": "",
      "start_time": 1344.28,
      "end_time": 1320.0
    },
    {
      "text": " So we started from one subset, one subtree at a time from the bottom and then we started",
      "start_time": 1327.0,
      "end_time": null
    },
    {
      "text": " we moved up slowly and then we made sure that up to the root everything is in the form of a heap.",
      "start_time": 1350.0,
      "end_time": 1356.0
    },
    {
      "text": " So, this is how the construction had to happen and during this process you could see that at",
      "start_time": 1356.0,
      "end_time": 1362.48
    },
    {
      "text": " every level for every key ok, we had to compare one comparison was whichever is the greater child",
      "start_time": 1362.48,
      "end_time": 1370.72
    },
    {
      "text": " that is one comparison and between the parent and child comparison is made and we do the swapping.",
      "start_time": 1370.72,
      "end_time": 1377.2
    },
    {
      "text": "",
      "start_time": 1377.2,
      "end_time": 1350.0
    },
    {
      "text": " So, two comparisons for one key we did.",
      "start_time": 1352.56,
      "end_time": null
    },
    {
      "text": " And if we are talking about key at this level, then we may have to move it all the way down.",
      "start_time": 1380.0,
      "end_time": 1386.8
    },
    {
      "text": " So, if a key is at level 0 and you are at height H, so H minus I levels all the way we may have to",
      "start_time": 1386.8,
      "end_time": 1394.48
    },
    {
      "text": " move up this key. So, every time when we move up we have to make two comparisons one between the",
      "start_time": 1394.48,
      "end_time": 1400.56
    },
    {
      "text": " children and one between parent and child. So, those many comparisons for every key,",
      "start_time": 1400.56,
      "end_time": 1405.52
    },
    {
      "text": "",
      "start_time": 1405.52,
      "end_time": 1380.0
    },
    {
      "text": " So, like that you have to do it for every parent key here that is the way in which the",
      "start_time": 1384.48,
      "end_time": null
    },
    {
      "text": " the comparisons are going to be done in the case of the bottom up approach, is that clear?",
      "start_time": 1410.0,
      "end_time": 1417.2
    },
    {
      "text": " So now, let us look at the algorithm for such a bottom up approach method. So, please note",
      "start_time": 1417.2,
      "end_time": 1422.76
    },
    {
      "text": " that the elements are from 1 to n. So, you know that we have to slowly construct one",
      "start_time": 1422.76,
      "end_time": 1429.92
    },
    {
      "text": " small subtree at a time starting from n by 2 position and all the way go up to 1, the",
      "start_time": 1429.92,
      "end_time": 1436.36
    },
    {
      "text": "",
      "start_time": 1436.36,
      "end_time": 1410.0
    },
    {
      "text": " top most position because it is bottom up we start from the last",
      "start_time": 1415.48,
      "end_time": null
    },
    {
      "text": " parent, we will go up to the first parent. So, that is what is indicated here n by 2",
      "start_time": 1440.0,
      "end_time": 1445.84
    },
    {
      "text": " to down 1. So, what I am going to do is I am going to keep that as the kth element,",
      "start_time": 1445.84,
      "end_time": 1453.84
    },
    {
      "text": " ok. So, here the position is k and the value at that position is h of k. So, you can see",
      "start_time": 1453.84,
      "end_time": 1462.04
    },
    {
      "text": "",
      "start_time": 1462.04,
      "end_time": 1440.0
    },
    {
      "text": " that here in this position, this is in the previous I will show you. So, here.",
      "start_time": 1447.16,
      "end_time": null
    },
    {
      "text": " this is your i, this is your i and then value is 25 and then you once this is done then",
      "start_time": 1470.0,
      "end_time": 1486.92
    },
    {
      "text": " we have to do it at this level. So, we come here. So, like that we next we come here and",
      "start_time": 1486.92,
      "end_time": 1491.92
    },
    {
      "text": " so on right we keep coming down. So, this position is captured when this parent is being",
      "start_time": 1491.92,
      "end_time": 1498.76
    },
    {
      "text": "",
      "start_time": 1498.76,
      "end_time": 1470.0
    },
    {
      "text": " consider this position is",
      "start_time": 1473.0,
      "end_time": null
    },
    {
      "text": " captured compared, next we come to this question compared, next we come to this question but",
      "start_time": 1500.0,
      "end_time": 1505.28
    },
    {
      "text": " we are out of the bounds like that it starts. So, let us look at the algorithm for this.",
      "start_time": 1505.28,
      "end_time": 1512.32
    },
    {
      "text": "",
      "start_time": 1512.32,
      "end_time": 1500.0
    },
    {
      "text": " So, k the ith position element ok. So, here so, in this case these are the",
      "start_time": 1517.64,
      "end_time": null
    },
    {
      "text": " only two parents now we are talking about all rest of them are least. So, this is I",
      "start_time": 1530.0,
      "end_time": 1536.1
    },
    {
      "text": " will run from 2 to 1, this is 1 and 2 ok. So, I will run from 2 to 1. So, you have to",
      "start_time": 1536.1,
      "end_time": 1543.56
    },
    {
      "text": " make this as a heap first correct. So, this is treated as k and the value at this position",
      "start_time": 1543.56,
      "end_time": 1550.8
    },
    {
      "text": " is the value v ok. Then initially we do not know whether it is in the form of a heap or",
      "start_time": 1550.8,
      "end_time": 1557.36
    },
    {
      "text": "",
      "start_time": 1557.36,
      "end_time": 1530.0
    },
    {
      "text": " not. So let us say we have...",
      "start_time": 1532.0,
      "end_time": null
    },
    {
      "text": " We have 18, assume that it is already in the form of a heap, 20, 25, 18 and 25.",
      "start_time": 1560.0,
      "end_time": 1567.16
    },
    {
      "text": " So it is in the form of a heap.",
      "start_time": 1567.16,
      "end_time": 1569.2
    },
    {
      "text": " So I am going to, so while this is not a heap, while this is not a heap and 2 star k, see",
      "start_time": 1569.2,
      "end_time": 1576.6
    },
    {
      "text": " 52 if you are considering as a parent, ok, where will its left child be?",
      "start_time": 1576.6,
      "end_time": 1581.32
    },
    {
      "text": " It will be at position 2k.",
      "start_time": 1581.32,
      "end_time": 1583.32
    },
    {
      "text": " Now if 2k position has to be well within the tree, right?",
      "start_time": 1583.32,
      "end_time": 1586.8
    },
    {
      "text": "",
      "start_time": 1586.8,
      "end_time": 1560.0
    },
    {
      "text": " So what is the value of n in this case 1, 2, 3.",
      "start_time": 1563.2,
      "end_time": null
    },
    {
      "text": " 4, 5, ok. For a parent, the child if it all has to be present, the left child is at least",
      "start_time": 1590.0,
      "end_time": 1600.48
    },
    {
      "text": " should be present for you to compare, right, ok. So, at this position it is not a heave",
      "start_time": 1600.48,
      "end_time": 1606.24
    },
    {
      "text": " and it has a left child. How do you know? The 2k, ok, k is the parent position, 2k is",
      "start_time": 1606.24,
      "end_time": 1612.84
    },
    {
      "text": " the left child position, at least it should have the left child, is not it, for you to",
      "start_time": 1612.84,
      "end_time": 1616.0
    },
    {
      "text": "",
      "start_time": 1616.0,
      "end_time": 1590.0
    },
    {
      "text": " compare and convert it into heave. So 2k is less than or equal to.",
      "start_time": 1594.0,
      "end_time": null
    },
    {
      "text": " equal to n, then only I perform the hippifying operation. So, what do you mean by hippifying?",
      "start_time": 1620.0,
      "end_time": 1626.68
    },
    {
      "text": " First I will set the j to 2 star k which is the left child of the current parent. So,",
      "start_time": 1626.68,
      "end_time": 1631.08
    },
    {
      "text": " where is the parent? Parent is at position k, the left child is at position 2 k.",
      "start_time": 1631.08,
      "end_time": 1636.48
    },
    {
      "text": " Now, I am going to check if j is less than n, j is less, next I am going to compare is",
      "start_time": 1636.48,
      "end_time": 1647.96
    },
    {
      "text": "",
      "start_time": 1647.96,
      "end_time": 1620.0
    },
    {
      "text": " J less than n.",
      "start_time": 1622.0,
      "end_time": null
    },
    {
      "text": " If j is less than n, then you know we can go up to n position, is not it?",
      "start_time": 1650.0,
      "end_time": 1655.92
    },
    {
      "text": " So which means that the j will also have, that means that we will also have a right",
      "start_time": 1655.92,
      "end_time": 1661.2
    },
    {
      "text": " position child.",
      "start_time": 1661.2,
      "end_time": 1663.08
    },
    {
      "text": " So if j is less than n, then up to n the valid positions are present, is not it?",
      "start_time": 1663.08,
      "end_time": 1667.88
    },
    {
      "text": " So then there is also a right child for this parent.",
      "start_time": 1667.88,
      "end_time": 1670.72
    },
    {
      "text": " So the right child is, I hope you get this, see if k is a parent, 2k will be the position",
      "start_time": 1670.72,
      "end_time": 1677.84
    },
    {
      "text": " of the left child.",
      "start_time": 1677.84,
      "end_time": 1678.84
    },
    {
      "text": "",
      "start_time": 1678.84,
      "end_time": 1650.0
    },
    {
      "text": " 2k plus 1 will be...",
      "start_time": 1651.12,
      "end_time": null
    },
    {
      "text": " be the position of the right child. But 2k is a position of the left child, does it mean",
      "start_time": 1680.0,
      "end_time": 1684.38
    },
    {
      "text": " that it has a left child? See only valid positions for the tree are up to n. So, if 2k is less",
      "start_time": 1684.38,
      "end_time": 1690.6
    },
    {
      "text": " than n then only less than or equal to n then we say that it has a left child, otherwise",
      "start_time": 1690.6,
      "end_time": 1695.88
    },
    {
      "text": " there is no child for this particular node. Then j is set to 2 star k and then j if it",
      "start_time": 1695.88,
      "end_time": 1703.48
    },
    {
      "text": " is less than n still it also has a right child. If it has a right child I have to compare",
      "start_time": 1703.48,
      "end_time": 1708.64
    },
    {
      "text": "",
      "start_time": 1708.64,
      "end_time": 1680.0
    },
    {
      "text": " if the left child is.",
      "start_time": 1681.16,
      "end_time": null
    },
    {
      "text": " less than the right child and then j is said to greater of the two children. So, j is said to",
      "start_time": 1710.0,
      "end_time": 1715.28
    },
    {
      "text": " greater of the two children here. Now, we have to compare the element at position this v 52",
      "start_time": 1715.28,
      "end_time": 1721.44
    },
    {
      "text": " with respect to 25. If it is already in the form of a heap, I don't have to worry. If v is greater",
      "start_time": 1721.44,
      "end_time": 1727.92
    },
    {
      "text": " than h of j, this value value is greater than h of j, it is already in the form of a heap,",
      "start_time": 1727.92,
      "end_time": 1734.16
    },
    {
      "text": " I will just set the heap to true because it is at that position heap is true. Otherwise, I need to",
      "start_time": 1734.16,
      "end_time": 1739.6
    },
    {
      "text": " swap the contents, so h of k because you would have copied, so 52 will come here, h of j",
      "start_time": 1740.0,
      "end_time": 1747.48
    },
    {
      "text": " will come here if that was there and then the operation will go on further, but right",
      "start_time": 1747.48,
      "end_time": 1753.92
    },
    {
      "text": " now this is done now, ok. So, next we have to pick up this parent.",
      "start_time": 1753.92,
      "end_time": 1758.76
    },
    {
      "text": " So, similarly the same set of if this is k and greater of the two children is let us",
      "start_time": 1758.76,
      "end_time": 1763.96
    },
    {
      "text": " say their value is j, these two need to be swapped and this will become k and again greater",
      "start_time": 1763.96,
      "end_time": 1769.72
    },
    {
      "text": "",
      "start_time": 1769.72,
      "end_time": 1740.0
    },
    {
      "text": " of the.",
      "start_time": 1740.5,
      "end_time": null
    },
    {
      "text": " two children, this will become k, but greater the two children is not there, so we stop",
      "start_time": 1770.0,
      "end_time": 1774.48
    },
    {
      "text": " the iteration. This is how the bottom up heap is going to work in the case of the construction",
      "start_time": 1774.48,
      "end_time": 1780.6
    },
    {
      "text": " of the heap and the elements are placed in the form of an array.",
      "start_time": 1780.6,
      "end_time": 1784.4
    },
    {
      "text": " So, now since as I said this is at position 0 and the maximum h is height is h, h minus",
      "start_time": 1784.4,
      "end_time": 1795.68
    },
    {
      "text": "",
      "start_time": 1795.68,
      "end_time": 1770.0
    },
    {
      "text": " i is the number of positions of comparison for this.",
      "start_time": 1775.6,
      "end_time": null
    },
    {
      "text": " because this may go all the way down, right. So, H minus i is the number of comparisons",
      "start_time": 1800.0,
      "end_time": 1808.48
    },
    {
      "text": " for this element and every time when we take up this node, one comparison between greater",
      "start_time": 1808.48,
      "end_time": 1814.84
    },
    {
      "text": " of the two children, one comparison is between greater of the two children and another comparison",
      "start_time": 1814.84,
      "end_time": 1820.8
    },
    {
      "text": " is between greater of the two, this child and the parent. So, two comparisons for one",
      "start_time": 1820.8,
      "end_time": 1826.88
    },
    {
      "text": "",
      "start_time": 1826.88,
      "end_time": 1800.0
    },
    {
      "text": " key and the two comms.",
      "start_time": 1803.12,
      "end_time": null
    },
    {
      "text": " comparisons and how many comparisons in the worst case, it may go all the way down 2 into",
      "start_time": 1830.0,
      "end_time": 1835.36
    },
    {
      "text": " H minus A comparisons.",
      "start_time": 1835.36,
      "end_time": 1837.36
    },
    {
      "text": " This we do it for all the keys at level I, all the keys at level I and this we have to",
      "start_time": 1837.36,
      "end_time": 1844.08
    },
    {
      "text": " do it for every level parent.",
      "start_time": 1844.08,
      "end_time": 1846.0
    },
    {
      "text": " So, 0 to H minus 1 level we have to do it.",
      "start_time": 1846.0,
      "end_time": 1849.0
    },
    {
      "text": " So, this will be the efficiency for a heap tree in the bottom up approach.",
      "start_time": 1849.0,
      "end_time": 1853.8
    },
    {
      "text": "",
      "start_time": 1853.8,
      "end_time": 1830.0
    },
    {
      "text": " So, in fact, this may not be so much required in this course, but since we have\u2026",
      "start_time": 1836.2,
      "end_time": null
    },
    {
      "text": " are discussing both bottom up approach and top down approach, I thought it is good to",
      "start_time": 1860.0,
      "end_time": 1864.46
    },
    {
      "text": " have this efficiency clause here, ok. So, we say that two comparisons for one key and",
      "start_time": 1864.46,
      "end_time": 1872.62
    },
    {
      "text": " at every level and how many ever levels it has, whichever level it is in. Suppose a key",
      "start_time": 1872.62,
      "end_time": 1878.24
    },
    {
      "text": " is at the 8th level, the maximum number of comparisons that may be required because it",
      "start_time": 1878.24,
      "end_time": 1882.74
    },
    {
      "text": " may move down all the way, so is H minus i. So, this is for one key, this has to be counted",
      "start_time": 1882.74,
      "end_time": 1889.02
    },
    {
      "text": "",
      "start_time": 1889.02,
      "end_time": 1860.0
    },
    {
      "text": " for all that.",
      "start_time": 1860.92,
      "end_time": null
    },
    {
      "text": " key is in a level i and like that for all levels we have to consider. So, when we do",
      "start_time": 1890.0,
      "end_time": 1894.96
    },
    {
      "text": " this, so in a level 1 level it is a fully binary tree, it is a complete binary tree.",
      "start_time": 1894.96,
      "end_time": 1900.4
    },
    {
      "text": " So, 2 power i nodes will be present in the worst case for that level. So, this when we",
      "start_time": 1900.4,
      "end_time": 1906.08
    },
    {
      "text": " run it when we prove this, this will turn out to be 2n minus log n. So, this is of the",
      "start_time": 1906.08,
      "end_time": 1912.32
    },
    {
      "text": " class of order of n. So, it is a linear time algorithm. So, the bottom of heap construction",
      "start_time": 1912.32,
      "end_time": 1918.8
    },
    {
      "text": "",
      "start_time": 1918.8,
      "end_time": 1890.0
    },
    {
      "text": " can be done in leaves.",
      "start_time": 1891.2,
      "end_time": null
    },
    {
      "text": " So, that is the time complexity requirement for the case of heap construction here.",
      "start_time": 1920.0,
      "end_time": 1926.72
    },
    {
      "text": " Now, let us look at move forward to the top down approach.",
      "start_time": 1926.72,
      "end_time": 1930.92
    },
    {
      "text": " So, in the top down approach, again same set of elements have been taken.",
      "start_time": 1930.92,
      "end_time": 1936.08
    },
    {
      "text": " Here in the top down approach, what I will do is instead of going from bottom to top,",
      "start_time": 1936.08,
      "end_time": 1942.28
    },
    {
      "text": " we go from top to down.",
      "start_time": 1942.28,
      "end_time": 1944.92
    },
    {
      "text": "",
      "start_time": 1944.92,
      "end_time": 1920.0
    },
    {
      "text": " So, one element at a time I will finish constructing the heap and then I will.",
      "start_time": 1925.04,
      "end_time": null
    },
    {
      "text": " add on new element to the heap and see what happens. So, here this is the first element",
      "start_time": 1950.0,
      "end_time": 1957.6
    },
    {
      "text": " 25. So, these are all in the array. So, I have to heapify. So, I will consider 25 as",
      "start_time": 1957.6,
      "end_time": 1965.44
    },
    {
      "text": " a heap. So, just 25 considered as a heap as an element in the binary tree it satisfies",
      "start_time": 1965.44,
      "end_time": 1973.72
    },
    {
      "text": " the heap principle. So, it is a valid heap now. The next element that I am considering",
      "start_time": 1973.72,
      "end_time": 1979.16
    },
    {
      "text": "",
      "start_time": 1979.16,
      "end_time": 1950.0
    },
    {
      "text": " is 57.",
      "start_time": 1950.88,
      "end_time": null
    },
    {
      "text": " So, now what we are saying is if 57 is placed in the array at this point only will it be",
      "start_time": 1980.0,
      "end_time": 1987.46
    },
    {
      "text": " satisfying the descending priority Q principle.",
      "start_time": 1987.46,
      "end_time": 1991.34
    },
    {
      "text": " So, here if you write like this 25 is here if 25 is at position 1 and 57 is at position",
      "start_time": 1991.34,
      "end_time": 2000.74
    },
    {
      "text": " 2, you can see that the parents 57's parent is 25.",
      "start_time": 2000.74,
      "end_time": 2005.78
    },
    {
      "text": " So, you cannot allow this to happen.",
      "start_time": 2005.78,
      "end_time": 2009.22
    },
    {
      "text": "",
      "start_time": 2009.22,
      "end_time": 1980.0
    },
    {
      "text": " So",
      "start_time": 1982.0,
      "end_time": null
    },
    {
      "text": " 25 will shift down shift that is a shift up and shift down operations, 25 will come to",
      "start_time": 2010.0,
      "end_time": 2017.76
    },
    {
      "text": " the place of 57 and then you will see if can we place 57 here.",
      "start_time": 2017.76,
      "end_time": 2028.16
    },
    {
      "text": " In this case see what happens is 57 will be here, but this cannot happen so 25 will shift",
      "start_time": 2028.16,
      "end_time": 2035.76
    },
    {
      "text": "",
      "start_time": 2035.76,
      "end_time": 2010.0
    },
    {
      "text": " down and I will see if 57 can be placed here.",
      "start_time": 2014.24,
      "end_time": null
    },
    {
      "text": " had further parents then I would have had to check but in this case there are only two",
      "start_time": 2040.0,
      "end_time": 2044.88
    },
    {
      "text": " so I have to modify shift down and place 57 at that position.",
      "start_time": 2044.88,
      "end_time": 2050.88
    },
    {
      "text": " So 25 is a heap so it is fine but now 57 as it is if you consider it is not a heap so",
      "start_time": 2050.88,
      "end_time": 2057.24
    },
    {
      "text": " you will have to 25 is less than 57 it has to be shifted down okay and therefore this",
      "start_time": 2057.24,
      "end_time": 2065.2
    },
    {
      "text": "",
      "start_time": 2065.2,
      "end_time": 2040.0
    },
    {
      "text": " particular now processes it is a heave.",
      "start_time": 2044.8,
      "end_time": null
    },
    {
      "text": " in the array it will be like this. So, we have done two element heap construction now,",
      "start_time": 2070.0,
      "end_time": 2076.8
    },
    {
      "text": " we have to pick up one more and place it. So, now 48 is in the third place in the array,",
      "start_time": 2076.8,
      "end_time": 2082.96
    },
    {
      "text": " 48 is in the third place, so it will come here automatically. So, now in insertion of 48 at",
      "start_time": 2082.96,
      "end_time": 2090.24
    },
    {
      "text": " the same place, it has not affected my descending heap and it is already a heap, so therefore,",
      "start_time": 2090.24,
      "end_time": 2095.84
    },
    {
      "text": "",
      "start_time": 2095.84,
      "end_time": 2070.0
    },
    {
      "text": " there is no problem. Next let us look at 37.",
      "start_time": 2076.0,
      "end_time": null
    },
    {
      "text": " So, now if you look at 37 which will be 37 parent see you have to look at here because",
      "start_time": 2100.0,
      "end_time": 2108.28
    },
    {
      "text": " these modifications have been done this is not the original now original is gone.",
      "start_time": 2108.28,
      "end_time": 2112.52
    },
    {
      "text": " So, we have moved elements.",
      "start_time": 2112.52,
      "end_time": 2114.12
    },
    {
      "text": " So, 37 parent is 25.",
      "start_time": 2114.12,
      "end_time": 2116.52
    },
    {
      "text": " Now, if you retain 37 here itself it will not satisfy the heaps principle.",
      "start_time": 2116.52,
      "end_time": 2121.52
    },
    {
      "text": " So, 25 will shift down ok.",
      "start_time": 2121.52,
      "end_time": 2124.72
    },
    {
      "text": " Now, 37 further its parent is looked at.",
      "start_time": 2124.72,
      "end_time": 2128.36
    },
    {
      "text": "",
      "start_time": 2128.36,
      "end_time": 2100.0
    },
    {
      "text": " 37 parent is dead.",
      "start_time": 2102.0,
      "end_time": null
    },
    {
      "text": " If this is the position of the child, this is where its parent is present.",
      "start_time": 2130.0,
      "end_time": 2137.36
    },
    {
      "text": " Now parent cannot be 25 in the deciding priority queue, so 25 will slide to 37's position.",
      "start_time": 2137.36,
      "end_time": 2143.64
    },
    {
      "text": " So now I will see if I can place my 37 here.",
      "start_time": 2143.64,
      "end_time": 2149.28
    },
    {
      "text": " If this is the child's position where its parent 57, so 37 and 57 are compared, so you",
      "start_time": 2149.28,
      "end_time": 2155.92
    },
    {
      "text": " can safely place 37.",
      "start_time": 2155.92,
      "end_time": 2158.12
    },
    {
      "text": "",
      "start_time": 2158.12,
      "end_time": 2130.0
    },
    {
      "text": " Because if this were to be sub-",
      "start_time": 2132.0,
      "end_time": null
    },
    {
      "text": " some other value let us say 38 or something like that or maybe 36.",
      "start_time": 2160.0,
      "end_time": 2167.48
    },
    {
      "text": " If you had 36 here and 36 also should have been slided down and then you would have placed",
      "start_time": 2167.48,
      "end_time": 2173.0
    },
    {
      "text": " 37.",
      "start_time": 2173.0,
      "end_time": 2174.0
    },
    {
      "text": " See I will write here if you had 57, 25, 48 and 37.",
      "start_time": 2174.0,
      "end_time": 2181.36
    },
    {
      "text": " So you cannot allow 37 to be retained here because its parent is 25 in this tree, its",
      "start_time": 2181.36,
      "end_time": 2188.12
    },
    {
      "text": "",
      "start_time": 2188.12,
      "end_time": 2160.0
    },
    {
      "text": " The experience is 25 and 25",
      "start_time": 2162.0,
      "end_time": null
    },
    {
      "text": " we will have to shift down here, 37 I have captured it another.",
      "start_time": 2190.0,
      "end_time": 2194.68
    },
    {
      "text": " So can I place 37 here?",
      "start_time": 2194.68,
      "end_time": 2196.64
    },
    {
      "text": " For that I have to look at its parent's position right.",
      "start_time": 2196.64,
      "end_time": 2199.36
    },
    {
      "text": " So if its parent's position right now is 57 therefore 37 can come here that is not",
      "start_time": 2199.36,
      "end_time": 2204.12
    },
    {
      "text": " a problem.",
      "start_time": 2204.12,
      "end_time": 2205.12
    },
    {
      "text": " We have found a place holder for this but if this were to be let us say 36 for whatever",
      "start_time": 2205.12,
      "end_time": 2210.08
    },
    {
      "text": " reason then 25 will slide down but 37 cannot be placed here.",
      "start_time": 2210.08,
      "end_time": 2216.12
    },
    {
      "text": "",
      "start_time": 2216.12,
      "end_time": 2190.0
    },
    {
      "text": " 36 will also slide down and then you will have to place",
      "start_time": 2193.32,
      "end_time": null
    },
    {
      "text": " So, like that you have to keep doing down operations.",
      "start_time": 2220.0,
      "end_time": 2224.56
    },
    {
      "text": " So, from the current position you find its parent and see who is sitting in the parent's",
      "start_time": 2224.56,
      "end_time": 2230.12
    },
    {
      "text": " position.",
      "start_time": 2230.12,
      "end_time": 2231.12
    },
    {
      "text": " If the parent value is lesser than that of the given value, you move the parent's position",
      "start_time": 2231.12,
      "end_time": 2236.32
    },
    {
      "text": " element to this position.",
      "start_time": 2236.32,
      "end_time": 2238.28
    },
    {
      "text": " Again check its parent.",
      "start_time": 2238.28,
      "end_time": 2240.04
    },
    {
      "text": " If that parent is also smaller than the given element, then move that to this position.",
      "start_time": 2240.04,
      "end_time": 2245.36
    },
    {
      "text": " Like this you can only go up to the start.",
      "start_time": 2245.36,
      "end_time": 2247.16
    },
    {
      "text": "",
      "start_time": 2247.16,
      "end_time": 2220.0
    },
    {
      "text": " So, once you have found then fix the 37 here.",
      "start_time": 2222.72,
      "end_time": null
    },
    {
      "text": " So, you will have to like that fix a proper position for 37 so that the heap principle",
      "start_time": 2250.0,
      "end_time": 2254.96
    },
    {
      "text": " is followed.",
      "start_time": 2254.96,
      "end_time": 2255.96
    },
    {
      "text": " So, let us look at that now.",
      "start_time": 2255.96,
      "end_time": 2257.64
    },
    {
      "text": " So, insert 37 as I said in the tree form it looks like this 37 parent is 25 it is not",
      "start_time": 2257.64,
      "end_time": 2264.72
    },
    {
      "text": " proper so 25 has to come down 37 can be placed here.",
      "start_time": 2264.72,
      "end_time": 2269.28
    },
    {
      "text": " So, this is a heap now so this is fine.",
      "start_time": 2269.28,
      "end_time": 2273.12
    },
    {
      "text": " So, next element to be pushed is 12.",
      "start_time": 2273.12,
      "end_time": 2275.52
    },
    {
      "text": " So, let us look at 12.",
      "start_time": 2275.52,
      "end_time": 2277.28
    },
    {
      "text": "",
      "start_time": 2277.28,
      "end_time": 2250.0
    },
    {
      "text": " So, right now 12 is in this position.",
      "start_time": 2252.56,
      "end_time": null
    },
    {
      "text": " So, again where is its parent? 12th parent is see 25 children of 57, 48, ok. No, this",
      "start_time": 2280.0,
      "end_time": 2289.92
    },
    {
      "text": " is the tree that we have to look at now. So, 57, 37, 48, 25, ok, then we have 12, 90,",
      "start_time": 2289.92,
      "end_time": 2299.04
    },
    {
      "text": " 28, 36, 33, ok. This is the array that we have to pick up. So, 12th parent we have to see.",
      "start_time": 2299.04,
      "end_time": 2306.96
    },
    {
      "text": "",
      "start_time": 2306.96,
      "end_time": 2280.0
    },
    {
      "text": " The tree will be 57 then 37.",
      "start_time": 2283.08,
      "end_time": null
    },
    {
      "text": " Then we have 25 and this is where my 12 is present.",
      "start_time": 2310.0,
      "end_time": 2316.12
    },
    {
      "text": " So 12 is already in a position where the designing key principle is satisfied.",
      "start_time": 2316.12,
      "end_time": 2321.82
    },
    {
      "text": " So there is no need to move.",
      "start_time": 2321.82,
      "end_time": 2323.4
    },
    {
      "text": " If 12 is here, its parent is at position 37 and 37 can be the parent of 12 and therefore",
      "start_time": 2323.4,
      "end_time": 2331.24
    },
    {
      "text": " it is following the property of designing it, it's fine.",
      "start_time": 2331.24,
      "end_time": 2334.48
    },
    {
      "text": " So next we have to move on to 92.",
      "start_time": 2334.48,
      "end_time": 2337.32
    },
    {
      "text": "",
      "start_time": 2337.32,
      "end_time": 2310.0
    },
    {
      "text": " 92 Spirits 92 will come",
      "start_time": 2314.48,
      "end_time": null
    },
    {
      "text": " here 92 parent will be 48 so 48 cannot be the parent of 92 so 48 will come to",
      "start_time": 2340.0,
      "end_time": 2346.32
    },
    {
      "text": " position of 92 then we check 57 can it be parent of if you place 92 here can",
      "start_time": 2346.32,
      "end_time": 2352.6
    },
    {
      "text": " that be satisfied no so 57 also will slide down and then 92 will be placed",
      "start_time": 2352.6,
      "end_time": 2358.44
    },
    {
      "text": " here so that is what is going to happen in the case of 92 so 92 and 48 are",
      "start_time": 2358.44,
      "end_time": 2364.2
    },
    {
      "text": " compared so we have to he epify that position 92 and 57 are compared we have",
      "start_time": 2364.2,
      "end_time": 2369.56
    },
    {
      "text": "",
      "start_time": 2369.56,
      "end_time": 2340.0
    },
    {
      "text": " hippies.",
      "start_time": 2340.5,
      "end_time": null
    },
    {
      "text": " that. So, like that you can see that it keeps coming down and finally 92 is fixed at its",
      "start_time": 2370.0,
      "end_time": 2376.4
    },
    {
      "text": " appropriate position which is a heap. Next let us consider 86. If it is placed there",
      "start_time": 2376.4,
      "end_time": 2381.8
    },
    {
      "text": " only here is the place where 86 is placed. So, I am not going to so insert 86 this is",
      "start_time": 2381.8,
      "end_time": 2390.16
    },
    {
      "text": " where it comes to. So, 86 again cannot be placed there. So, its parent 57 should come",
      "start_time": 2390.16,
      "end_time": 2396.16
    },
    {
      "text": "",
      "start_time": 2396.16,
      "end_time": 2370.0
    },
    {
      "text": " down ok. And then we have to compare it is.",
      "start_time": 2373.86,
      "end_time": null
    },
    {
      "text": " 692 but that's okay that position is okay so we stop at that heap. Next I",
      "start_time": 2400.0,
      "end_time": 2404.56
    },
    {
      "text": " consider 33's insertion so 33 is at the last position 33 is parent if you see",
      "start_time": 2404.56,
      "end_time": 2411.16
    },
    {
      "text": " 25 you cannot so you have to move 25 down and then 33 and 37 are compared",
      "start_time": 2411.16,
      "end_time": 2417.1
    },
    {
      "text": " mooching it's a heap and therefore we stop at this. This is how the top-down",
      "start_time": 2417.1,
      "end_time": 2421.7
    },
    {
      "text": " heap is constructed and this kind you you can see that we are running all the",
      "start_time": 2421.7,
      "end_time": 2428.3
    },
    {
      "text": "",
      "start_time": 2428.3,
      "end_time": 2400.0
    },
    {
      "text": " from YouTube.",
      "start_time": 2401.76,
      "end_time": null
    },
    {
      "text": " the elements and then we start inserting each of these elements into the trees. So, this",
      "start_time": 2430.0,
      "end_time": 2435.28
    },
    {
      "text": " kind of an operation will have to look through all of the elements correct.",
      "start_time": 2435.28,
      "end_time": 2439.84
    },
    {
      "text": " So, for example, in the worst case let us say the last element 33 ok, in the worst case",
      "start_time": 2439.84,
      "end_time": 2447.4
    },
    {
      "text": " last element 33 should have moved to all the way upright I mean if it were to be a greater",
      "start_time": 2447.4,
      "end_time": 2452.8
    },
    {
      "text": " element let us say if this were to be 100. So, this had to be moved all the way and every",
      "start_time": 2452.8,
      "end_time": 2458.32
    },
    {
      "text": "",
      "start_time": 2458.32,
      "end_time": 2430.0
    },
    {
      "text": " element must have been swapped.",
      "start_time": 2431.2,
      "end_time": null
    },
    {
      "text": " So, this kind of insertion is going to be a little more time consuming and then finally,",
      "start_time": 2460.0,
      "end_time": 2469.68
    },
    {
      "text": " the heap is going to be constructed.",
      "start_time": 2469.68,
      "end_time": 2471.72
    },
    {
      "text": " So, attach a new node with key k in its after the last leaf of the existing heap, then shift",
      "start_time": 2471.72,
      "end_time": 2477.68
    },
    {
      "text": " k up to its appropriate place in the new heap as follows.",
      "start_time": 2477.68,
      "end_time": 2480.92
    },
    {
      "text": " So, just now I said compare k with its parent key, if the latter is greater than or equal",
      "start_time": 2480.92,
      "end_time": 2487.08
    },
    {
      "text": "",
      "start_time": 2487.08,
      "end_time": 2460.0
    },
    {
      "text": " to get it. It's already a heaps so stop it.",
      "start_time": 2461.0,
      "end_time": 2462.56
    },
    {
      "text": " Suppose if it is not you have to swap and again you have to check its new parent this",
      "start_time": 2490.0,
      "end_time": 2494.68
    },
    {
      "text": " keep you keep doing it until its parent is not greater than its last parent or it reaches",
      "start_time": 2494.68,
      "end_time": 2502.56
    },
    {
      "text": " the root node where you will actually stop the whole thing.",
      "start_time": 2502.56,
      "end_time": 2506.08
    },
    {
      "text": " This is the heap constructions procedure for the top down ok.",
      "start_time": 2506.08,
      "end_time": 2509.88
    },
    {
      "text": " So, here the efficiency of insertion is of the order of login and the top bottom up approaches",
      "start_time": 2509.88,
      "end_time": 2516.64
    },
    {
      "text": " of the order n.",
      "start_time": 2516.64,
      "end_time": 2518.08
    },
    {
      "text": "",
      "start_time": 2518.08,
      "end_time": 2490.0
    },
    {
      "text": " So, that is the difference between the...",
      "start_time": 2492.0,
      "end_time": null
    },
    {
      "text": " the bottom up approach and the top down approach.",
      "start_time": 2520.0,
      "end_time": 2522.88
    },
    {
      "text": " So, let us go ahead and implement the heap construction using the programming concepts",
      "start_time": 2522.88,
      "end_time": 2530.24
    },
    {
      "text": " ok.",
      "start_time": 2530.24,
      "end_time": 2531.24
    },
    {
      "text": " Thank you.",
      "start_time": 2531.24,
      "end_time": 2531.56
    }
  ],
  "transcript_text": " Welcome back to PES University's online classes on data structures and its applications.  In this session, we will discuss a specialized binary tree called as heap, its definition,  examples and implementation.  Let's begin.  A heap tree is also a binary tree, which means that it will consist of set of nodes along   with the key information being present inside the  Then apart from this, what else it possesses?  It must be because you are not calling it as just plain binary tree, right?  So then what else it may possess?  Of course, a binary tree must satisfy certain requirements for it to be called as a heap  tree.  There are basically two requirements.  One is called as a shape requirement and the other one is called as a parental dominance   requirement.  Let us see what they mean. A binary tree is called as a heap tree when a when the tree  has fulfilled the shape requirement property. A binary tree must be a complete binary tree  for it to be called as a heap tree in the first place. This is one requirement,  this is a partial requirement. There is one more. Just because a complete binary tree we have,   you don't call it as heap but that is one of the requirements.  then the other requirement is that of the parental dominance property.  What do we mean by this?  If parent has some key value, then both its children will have information lesser than  that of the parent or vice versa.  If the parent has some key value, both its children will have information greater than  that of the parent.  Both are possible.   Let's see an example.  right 65 at the root, then you have both its children let us say 15 and 35, ok.  This satisfies the parental dominance property wherein the parent has 65 and the both its  children are 15 and 35 which are lesser than that of 65.  This should be satisfied at every level of course.   So here let us take 8 and then let us take 7.  nothing like the left child should be lesser or right child should be greater. It is between  the levels and between the parent and the children. So, the parental dominance says  that the parent has key value greater than that of the two children. Here also, so it  should be at every level in the binary tree, here 35 is greater than 8 and 7. Therefore,   we call such a binary tree see as a heap tree, but of course this is not satisfying the shi-  shape requirement, but I am just giving an example of what we mean by parental dominance  here.  Now, in this case if the parent has the value greater than that of the two children, it  is called as a descending heap.  It is a descending heap.  The vice versa if the as I said the parent may have information lesser than that of the   children. Then in which case this kind of a tree is called as an ascending tree.  So, both are possible.  So in this example, in this definition, it is only written as greater, but vice versa  is also possible.  The key at each node is lesser than or equal to its children, that is also possible.  So, here is the definition of a descending heap.  So overall, what we say a binary tree, when do you call it as a heap tree, we will call  that as a heap tree if the binary tree is a complete binary tree and it satisfies the   parental dog.  property. Such a tree is called as a heap tree. Now, when you construct the elements  as a heap, then this finds its applications in several of the programs. Like if you want  to implement the priority queue, earlier we have discussed in unit 2 a concept called  as priority queue and there we had looked at implementation of priority queue using arrays   as well as using linked list. But here after .  understanding the heaps, once again we will revisit the implementation of priority queue  using heap and see how the operations can be performed much more efficiently here than  over there, ok.  So that is one of the important applications of constructing a heap and using it for the  priority queue implementations and then we also can use make use of the heap in order  statistics like you want to get the largest element, kth largest element and so on because   it meant it.  some order here, such order statistics also we can make use of the heap data structure.  So it finds its applications in several of these programs like in draft traversals and  so on and that is why it is a very important data structure to study.  So let us continue.  So we have understood now the definition of a heap tree.  So how do we define the, so let us understand this through an example first.   We  what is a heap and what is not a heap. So, here is an example of a heap because you can see that  both the properties are satisfied. Here in this case example the first property the tree shape  requirement property is not satisfied because there is no node here it is not a complete binary tree.  This is a complete binary tree only here to the last rightmost we do not have a leaf but otherwise   is it satisfying the complete binary tree and the second.  property which is a parental dominance. See at 10, 5, 7 level it is satisfied, 7, 1 level  also it is satisfied, but it is not getting satisfied at this level and that is why it  is not a heap. Whereas for this both the shape requirement as well as the parental dominance  are satisfied and therefore, this is an example of a heap.   set there ok. Now, let us look at the properties related to heap. Since,  this heap is a complete binary tree, you will have nodes at every level and a nonlinearity  has been brought in.  Let us say heap has a height hedge, total height hedge.  So and with total number of nodes being n, so because they are distributed across in  a nonlinear fashion, both sides, the height of the tree can be proved as log into base  2.  So this is one of the important properties of such a tree.   The second property as you know just now given in the demo.  definition, the root of the heap will always have the largest element in the case of descending  heap, otherwise it will have the smallest element in the case of ascending heap.  Then the binary tree if it to be called as a heap, it is not just enough that it is satisfied  at the root level, but it has to be at every level, even the below descendants must be  heap.  So, that is the next property, a node of a heap considered with all its descendants   is also a heap.  Now, how do you place this kind of a heat tree in the memory?  Are we going to go for dynamic allocation or are you going to go for array implementation?  We have seen both the implementations while discussing the binary surgery.  There we went ahead and implemented the binary surgery using both dynamic and as well as  implicit array representation.   So there we have studied.  the way the housing of these nodes are going to be done in the array.  So here we are talking about a complete binary tree.  Because it is a complete binary tree, we can also arrange these nodes in the form of an  array where you can arrange these nodes from top down to left to right as we saw in the  binary search tree.  So you can see that these nodes can be arranged in the, I will take this example binary search  the heap tree.   So this can be placed at position.  This can be at position 2, this can be at 3, this will be at position 4, this is 5,  6.  So, you can place this kind of a heap tree in the form of an implicit array representation  that we have seen and we can place this 10 here, then 5 here.  So, top down left to right fashion and I have assumed now in this example, I have assumed   the position to start from 1.  And we have seen earlier that either you can start from position 1 or you can start from  position 0.  If you start from position 1, the left side will be at position.  If this position is k, this will be at position 2k and this will be at position 2k plus 1.  Like that it is going to be satisfied at every position.  So you have 5 and then you are going to place 7 and then we have 4 and then we have 2 and  then 1.   So this is so you can see.  that the normal issues that we had with array implementation or intermixing of vacant space  with the actual space that does not arise here because it is a complete binary tree.  All these positions are free.  So since all and only if there are vacant positions only towards the end they are there.  So intermixed of space vacant space and field space that kind of an issue does not arise  here.   it is nice to have an array presentation because it is a  implicit representation and we do not store the addresses explicitly, it is easier to  operate the tree if this heap is housed in an array.  So, this is how we are going to construct the heap by placing the elements into an array  instead of the dynamic implementation.  So, that is the fourth property that is being mentioned here.  So, you can see that heap can be implemented as an array by recording its elements in the   top room and let's do  right fashion. So, you can decide on whether to use the 0th location or not. So, in such  a representation what is going to happen? So, if you have a tree, if you have a tree   Okay, then 10, then you have 12, then 9, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,  22 like this let us say I have considered some six nodes assume 25. So, now this is an ascending  heap. Now in this case there are six nodes totally. So, n is equal to 6. So, you can see that  the nodes which are having children this node, this node and this node. So, 1, 2 and 3 and 4, 5,   six onwards, they are just leaves.  So, n by 2 flow those many positions 6 by 2 in this case 3, these are the parental positions.  So, these are the parental positions 1, 2, 3 and the subsequent next n by 2 positions  are 4, 5, 6 which are the child positions, you can observe that.  So, this property we will make use of while we construct the heap.  So, keep this point in mind.   So, in such a representation you can see that the parental.  nodes will be in the first n by 2 positions and the leaf will be occupying the last n  by 2 positions. And you also know the property that if the child is at position i, then the  left child will be at position 2i and 2i plus 1 if we start 1, otherwise if we start from  0 it will be at 2i plus 1 and 2i plus 2. So, that is the next representation that we are   talking about. So, let us move on. So, now we will see the edge.  example of how to construct a bottom up heap for this kind of elements. Let us say these  elements are right now stored in an array. So, let us consider an array, all these elements  are stored in the array in this manner 25, 57 and then 48, 37, 12, 92 and then 86 and   So, they are presently in the form of a .  .  an array, but this is only a binary tree now as of now.  So, if you look at the pictorial representation, right now the tree is present in an array  in this form and pictorially this is how this particular tree is looking like.  Now, you cannot leave it at that because we have to now convert this into a heap with  the given elements we are expected to convert this tree into a heap tree.   But as it is, is it a heap? That is what we have to look at.  So, now let us look at, let us say I am interested in constructing a descending heap, descending  heap.  So, let us say whether this is following the property of the descending heap.  So, the very first itself is not, the 25 and 57 is not a descending heap.  Here also you can, here it is possible and here it is again not a descending heap.  So, overall it is not satisfying the descending heap principle at every level.   So, we will have to find out whether at every place  whether the tree is satisfying descending heap and overall whether this is a heap tree,  okay. In terms of the shape requirement, yes, of course, it is a complete binary tree,  but in terms of the parental dominance property, this is not satisfying.  So, we need to look at how this can be modified, the elements can be moved around  to make sure that a heap is constructed, that is our motivation here. So, and also we will see   how much time requirement is needed.  And the way we are going to rearrange these elements to make it into a heap tree, for  that the methodology that we I am demonstrating now here is a bottom up approach and subsequently  we will also see how a top down approach can be used for construction of the heap.  So, first let us look at the bottom up approach.  In the bottom up approach what we are going to do is to construct one heap at a time which   is a suppree.  And for that I am going to consider the last parent that is present to the first parent.  So you can see that there are 8 nodes here, okay.  So there are 8 nodes and you can see the last parent will be deciding at position 4.  So 8 by 2 which is 4, n by 2 positions.  Parental positions will be starting from 1 to n by 2, right.  So the last parent will be at position 4 if there are 8 nodes.   The war?  this type of construction does is in order to convert this given binary tree into a heap,  it uses a bottom up approach to make sure that the heap is constructed.  So what do we mean by this?  We know that the first parent is starting at position 4.  You can see that remaining questions are all leaves.  So I am going to start from this position and I am going to consider this subtree here   And I  I am going to see whether this is already a heap or not.  So here this part I am going to convert it into heap.  Is that clear?  Now after I consider this, this part is done let us say.  Now I go to the next parent in the sequence and with respect to this parent whether the  heap property is satisfied or not I am going to consider that.  If that is not satisfied I am going to adjust it otherwise I will leave it as it is.   I will consider the next video.  parent. When I consider the next parent, this whole thing has to be considered, please note  that ok. So, I am going to see with reference to this parent whether the entire subtree is a heap  or not. Once that is done, then I will go to this. With respect to this, see what happens is  there will be only few moments that will be required because you are already modifying these  two. So, there will not be much movement here ok. The idea is to make it in a quick time. You   are given a sequence of a...  elements and these elements are right now in the form of a binary tree, general binary  tree. How do I modify these elements such that they form a descending heap? That is  the idea. So, that is known as a heap tree. So, with respect to this tree, the whole subtree  must be satisfying the heap. That is how I am going to rearrange. So, let us see how  this whole thing is to be carried out. So, as I said, first we will start with at k equal   to 4, the value is 37.  Now, this 37, can it be there itself is this level satisfying the heap or not is what we  have to consider.  Now, for that 37 right now is having only one child.  It does see what we said in the parental dominance property is that both its children must be  having value lesser than that of the root because I am talking about descending heap.  But in this case what is happening is there is only one child.   So, we will have to just compare it with this child, ok.  So, in the absence of both the children being present, all that we need to do is to compare  33 and 37.  Now, it is so happening that already the parent has higher value than the child.  So, at this point, there is parental dominance already happening.  So, there is nothing that needs to be moved and the tree remains the same after this comparison.  So, there is no change at all.  Now, let us move on to the next position.   Now in the next one we are having  the next parent at position 48. So, we have to consider this subtree to find out, figure  out whether the heap is present here or not. So, definitely not because we are talking  about descending heap. So, we have 48 as the parent and 90 to 86 as its children. So,  definitely it is not satisfying the parental dominance property and therefore, we have   to convert this into a heat now. So in order to do that first thing  that I need to do is now which child's value that I need to move up that is what we have  to look at.  So here 92 is on the left side, 86 is on the right side, these are the two children of  48.  So between the two children whichever child has higher value that value has to be moved  up is that clear?  So that is what we have to look at.   So first my comparison is with respect to 92 and 86 ok and in between the 90 and 86 and the 90 and 86 and the 90 and 86 and the 90 and 86 and the 86 and the 86 and the 86  92 and 86, 92 is higher. So, if at all I am planning to move the or the swap the 2 it  is between 48 and 92. So, these 2 I am going to swap and then I am going to construct the  heap at this point. So, you can see that at this point the heap is constructed. At this  point also it is done, at this point also it is done now. So, we have to now move on   to this position ok.  here 57 again both its children are compared. When you compare both its children say we  start from here please note 57 both its children are compared in this case there is no problem  at all see below case it is already done. So, now you have to compare here 57 is compared  with 37 and 12. So, 37 and 12 both are smaller so no change is going to happen. So, this   all fine okay so that there is no  in the tree, it is already a heap. Next, let us consider 25, that is the last one.  So, now, we have to start from here. We have to see, please note that this is a heap now,  37, 33, that is a heap, this is also a heap, this whole thing is also a heap. Now, the  only thing that is left is with respect to this level, we have to find out if it is a   So, 25s both children are first compared.  between 57 and 92, 92 is greater. So, 92 has to move up. Now, when 92 moves up and 25  comes here, now again you cannot stop at that. See, you have to with respect to this the  whole thing has to be the heap. So, when 25 comes down again between the two children  86 is higher. So, 86 will move up and then 25 will move down. So, 92 and 25 are swapped   and then 25 and 86 are swapped.  in the next comparison and then finally you will be in a question to say that this is  a heap.  So, 25 and 86 are compared here and then this whole thing heap is constructed.  So, now we have the entire heap being constructed starting from this.  So initially the array had this.  Now once the heap is constructed, so your array is going to contain 92 at the first  position, 57 at the second, 86, 37, 12, 48, 25 and 33.   So this is how our...  original tree which was in this manner has been reformulated, we heapified and we have  constructed a heap out of the given set of elements and we have placed them in an array.  So this is the way in which the bottom up approach is going to work, is that clear?  So this was the original tree and this is the bottom up heap constructed.   So we started from one subset, one subtree at a time from the bottom and then we started  we moved up slowly and then we made sure that up to the root everything is in the form of a heap.  So, this is how the construction had to happen and during this process you could see that at  every level for every key ok, we had to compare one comparison was whichever is the greater child  that is one comparison and between the parent and child comparison is made and we do the swapping.   So, two comparisons for one key we did.  And if we are talking about key at this level, then we may have to move it all the way down.  So, if a key is at level 0 and you are at height H, so H minus I levels all the way we may have to  move up this key. So, every time when we move up we have to make two comparisons one between the  children and one between parent and child. So, those many comparisons for every key,   So, like that you have to do it for every parent key here that is the way in which the  the comparisons are going to be done in the case of the bottom up approach, is that clear?  So now, let us look at the algorithm for such a bottom up approach method. So, please note  that the elements are from 1 to n. So, you know that we have to slowly construct one  small subtree at a time starting from n by 2 position and all the way go up to 1, the   top most position because it is bottom up we start from the last  parent, we will go up to the first parent. So, that is what is indicated here n by 2  to down 1. So, what I am going to do is I am going to keep that as the kth element,  ok. So, here the position is k and the value at that position is h of k. So, you can see   that here in this position, this is in the previous I will show you. So, here.  this is your i, this is your i and then value is 25 and then you once this is done then  we have to do it at this level. So, we come here. So, like that we next we come here and  so on right we keep coming down. So, this position is captured when this parent is being   consider this position is  captured compared, next we come to this question compared, next we come to this question but  we are out of the bounds like that it starts. So, let us look at the algorithm for this.   So, k the ith position element ok. So, here so, in this case these are the  only two parents now we are talking about all rest of them are least. So, this is I  will run from 2 to 1, this is 1 and 2 ok. So, I will run from 2 to 1. So, you have to  make this as a heap first correct. So, this is treated as k and the value at this position  is the value v ok. Then initially we do not know whether it is in the form of a heap or   not. So let us say we have...  We have 18, assume that it is already in the form of a heap, 20, 25, 18 and 25.  So it is in the form of a heap.  So I am going to, so while this is not a heap, while this is not a heap and 2 star k, see  52 if you are considering as a parent, ok, where will its left child be?  It will be at position 2k.  Now if 2k position has to be well within the tree, right?   So what is the value of n in this case 1, 2, 3.  4, 5, ok. For a parent, the child if it all has to be present, the left child is at least  should be present for you to compare, right, ok. So, at this position it is not a heave  and it has a left child. How do you know? The 2k, ok, k is the parent position, 2k is  the left child position, at least it should have the left child, is not it, for you to   compare and convert it into heave. So 2k is less than or equal to.  equal to n, then only I perform the hippifying operation. So, what do you mean by hippifying?  First I will set the j to 2 star k which is the left child of the current parent. So,  where is the parent? Parent is at position k, the left child is at position 2 k.  Now, I am going to check if j is less than n, j is less, next I am going to compare is   J less than n.  If j is less than n, then you know we can go up to n position, is not it?  So which means that the j will also have, that means that we will also have a right  position child.  So if j is less than n, then up to n the valid positions are present, is not it?  So then there is also a right child for this parent.  So the right child is, I hope you get this, see if k is a parent, 2k will be the position  of the left child.   2k plus 1 will be...  be the position of the right child. But 2k is a position of the left child, does it mean  that it has a left child? See only valid positions for the tree are up to n. So, if 2k is less  than n then only less than or equal to n then we say that it has a left child, otherwise  there is no child for this particular node. Then j is set to 2 star k and then j if it  is less than n still it also has a right child. If it has a right child I have to compare   if the left child is.  less than the right child and then j is said to greater of the two children. So, j is said to  greater of the two children here. Now, we have to compare the element at position this v 52  with respect to 25. If it is already in the form of a heap, I don't have to worry. If v is greater  than h of j, this value value is greater than h of j, it is already in the form of a heap,  I will just set the heap to true because it is at that position heap is true. Otherwise, I need to  swap the contents, so h of k because you would have copied, so 52 will come here, h of j  will come here if that was there and then the operation will go on further, but right  now this is done now, ok. So, next we have to pick up this parent.  So, similarly the same set of if this is k and greater of the two children is let us  say their value is j, these two need to be swapped and this will become k and again greater   of the.  two children, this will become k, but greater the two children is not there, so we stop  the iteration. This is how the bottom up heap is going to work in the case of the construction  of the heap and the elements are placed in the form of an array.  So, now since as I said this is at position 0 and the maximum h is height is h, h minus   i is the number of positions of comparison for this.  because this may go all the way down, right. So, H minus i is the number of comparisons  for this element and every time when we take up this node, one comparison between greater  of the two children, one comparison is between greater of the two children and another comparison  is between greater of the two, this child and the parent. So, two comparisons for one   key and the two comms.  comparisons and how many comparisons in the worst case, it may go all the way down 2 into  H minus A comparisons.  This we do it for all the keys at level I, all the keys at level I and this we have to  do it for every level parent.  So, 0 to H minus 1 level we have to do it.  So, this will be the efficiency for a heap tree in the bottom up approach.   So, in fact, this may not be so much required in this course, but since we have\u2026  are discussing both bottom up approach and top down approach, I thought it is good to  have this efficiency clause here, ok. So, we say that two comparisons for one key and  at every level and how many ever levels it has, whichever level it is in. Suppose a key  is at the 8th level, the maximum number of comparisons that may be required because it  may move down all the way, so is H minus i. So, this is for one key, this has to be counted   for all that.  key is in a level i and like that for all levels we have to consider. So, when we do  this, so in a level 1 level it is a fully binary tree, it is a complete binary tree.  So, 2 power i nodes will be present in the worst case for that level. So, this when we  run it when we prove this, this will turn out to be 2n minus log n. So, this is of the  class of order of n. So, it is a linear time algorithm. So, the bottom of heap construction   can be done in leaves.  So, that is the time complexity requirement for the case of heap construction here.  Now, let us look at move forward to the top down approach.  So, in the top down approach, again same set of elements have been taken.  Here in the top down approach, what I will do is instead of going from bottom to top,  we go from top to down.   So, one element at a time I will finish constructing the heap and then I will.  add on new element to the heap and see what happens. So, here this is the first element  25. So, these are all in the array. So, I have to heapify. So, I will consider 25 as  a heap. So, just 25 considered as a heap as an element in the binary tree it satisfies  the heap principle. So, it is a valid heap now. The next element that I am considering   is 57.  So, now what we are saying is if 57 is placed in the array at this point only will it be  satisfying the descending priority Q principle.  So, here if you write like this 25 is here if 25 is at position 1 and 57 is at position  2, you can see that the parents 57's parent is 25.  So, you cannot allow this to happen.   So  25 will shift down shift that is a shift up and shift down operations, 25 will come to  the place of 57 and then you will see if can we place 57 here.  In this case see what happens is 57 will be here, but this cannot happen so 25 will shift   down and I will see if 57 can be placed here.  had further parents then I would have had to check but in this case there are only two  so I have to modify shift down and place 57 at that position.  So 25 is a heap so it is fine but now 57 as it is if you consider it is not a heap so  you will have to 25 is less than 57 it has to be shifted down okay and therefore this   particular now processes it is a heave.  in the array it will be like this. So, we have done two element heap construction now,  we have to pick up one more and place it. So, now 48 is in the third place in the array,  48 is in the third place, so it will come here automatically. So, now in insertion of 48 at  the same place, it has not affected my descending heap and it is already a heap, so therefore,   there is no problem. Next let us look at 37.  So, now if you look at 37 which will be 37 parent see you have to look at here because  these modifications have been done this is not the original now original is gone.  So, we have moved elements.  So, 37 parent is 25.  Now, if you retain 37 here itself it will not satisfy the heaps principle.  So, 25 will shift down ok.  Now, 37 further its parent is looked at.   37 parent is dead.  If this is the position of the child, this is where its parent is present.  Now parent cannot be 25 in the deciding priority queue, so 25 will slide to 37's position.  So now I will see if I can place my 37 here.  If this is the child's position where its parent 57, so 37 and 57 are compared, so you  can safely place 37.   Because if this were to be sub-  some other value let us say 38 or something like that or maybe 36.  If you had 36 here and 36 also should have been slided down and then you would have placed  37.  See I will write here if you had 57, 25, 48 and 37.  So you cannot allow 37 to be retained here because its parent is 25 in this tree, its   The experience is 25 and 25  we will have to shift down here, 37 I have captured it another.  So can I place 37 here?  For that I have to look at its parent's position right.  So if its parent's position right now is 57 therefore 37 can come here that is not  a problem.  We have found a place holder for this but if this were to be let us say 36 for whatever  reason then 25 will slide down but 37 cannot be placed here.   36 will also slide down and then you will have to place  So, like that you have to keep doing down operations.  So, from the current position you find its parent and see who is sitting in the parent's  position.  If the parent value is lesser than that of the given value, you move the parent's position  element to this position.  Again check its parent.  If that parent is also smaller than the given element, then move that to this position.  Like this you can only go up to the start.   So, once you have found then fix the 37 here.  So, you will have to like that fix a proper position for 37 so that the heap principle  is followed.  So, let us look at that now.  So, insert 37 as I said in the tree form it looks like this 37 parent is 25 it is not  proper so 25 has to come down 37 can be placed here.  So, this is a heap now so this is fine.  So, next element to be pushed is 12.  So, let us look at 12.   So, right now 12 is in this position.  So, again where is its parent? 12th parent is see 25 children of 57, 48, ok. No, this  is the tree that we have to look at now. So, 57, 37, 48, 25, ok, then we have 12, 90,  28, 36, 33, ok. This is the array that we have to pick up. So, 12th parent we have to see.   The tree will be 57 then 37.  Then we have 25 and this is where my 12 is present.  So 12 is already in a position where the designing key principle is satisfied.  So there is no need to move.  If 12 is here, its parent is at position 37 and 37 can be the parent of 12 and therefore  it is following the property of designing it, it's fine.  So next we have to move on to 92.   92 Spirits 92 will come  here 92 parent will be 48 so 48 cannot be the parent of 92 so 48 will come to  position of 92 then we check 57 can it be parent of if you place 92 here can  that be satisfied no so 57 also will slide down and then 92 will be placed  here so that is what is going to happen in the case of 92 so 92 and 48 are  compared so we have to he epify that position 92 and 57 are compared we have   hippies.  that. So, like that you can see that it keeps coming down and finally 92 is fixed at its  appropriate position which is a heap. Next let us consider 86. If it is placed there  only here is the place where 86 is placed. So, I am not going to so insert 86 this is  where it comes to. So, 86 again cannot be placed there. So, its parent 57 should come   down ok. And then we have to compare it is.  692 but that's okay that position is okay so we stop at that heap. Next I  consider 33's insertion so 33 is at the last position 33 is parent if you see  25 you cannot so you have to move 25 down and then 33 and 37 are compared  mooching it's a heap and therefore we stop at this. This is how the top-down  heap is constructed and this kind you you can see that we are running all the   from YouTube.  the elements and then we start inserting each of these elements into the trees. So, this  kind of an operation will have to look through all of the elements correct.  So, for example, in the worst case let us say the last element 33 ok, in the worst case  last element 33 should have moved to all the way upright I mean if it were to be a greater  element let us say if this were to be 100. So, this had to be moved all the way and every   element must have been swapped.  So, this kind of insertion is going to be a little more time consuming and then finally,  the heap is going to be constructed.  So, attach a new node with key k in its after the last leaf of the existing heap, then shift  k up to its appropriate place in the new heap as follows.  So, just now I said compare k with its parent key, if the latter is greater than or equal   to get it. It's already a heaps so stop it.  Suppose if it is not you have to swap and again you have to check its new parent this  keep you keep doing it until its parent is not greater than its last parent or it reaches  the root node where you will actually stop the whole thing.  This is the heap constructions procedure for the top down ok.  So, here the efficiency of insertion is of the order of login and the top bottom up approaches  of the order n.   So, that is the difference between the...  the bottom up approach and the top down approach.  So, let us go ahead and implement the heap construction using the programming concepts  ok.  Thank you."
}